<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>CLAUDE VERSION 2.0 - Tab Trainer</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { margin: 0 0 12px 0; }
    button, input, select { font-size: 16px; }
    button { padding: 10px 14px; }
    .row { display:flex; gap:16px; flex-wrap: wrap; align-items:center; }
    .panel { border:1px solid #ddd; border-radius:12px; padding:16px; min-width: 320px; }
    .big { font-size: 20px; font-weight: 650; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    label { display:block; font-size: 12px; opacity: 0.75; margin-bottom: 6px; }

    /* File upload styles */
    .upload-section {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      text-align: center;
      background: #f9f9f9;
      transition: all 0.2s ease;
    }
    .upload-section.dragover {
      border-color: #007bff;
      background: #e6f3ff;
    }
    .upload-section input[type="file"] {
      margin: 8px 0;
    }
    .upload-status {
      margin-top: 8px;
      font-size: 14px;
    }
    .upload-status.success {
      color: #1a7f37;
    }
    .upload-status.error {
      color: #b42318;
    }

    .notes { display:flex; gap:10px; flex-wrap: wrap; }
    .note {
      border:1px solid #ddd; border-radius:10px; padding:10px 12px; min-width:84px;
      text-align:center;
    }
    .note .t { font-size: 12px; opacity: 0.7; margin-top: 6px;}
    .note.hit { border-color: #1a7f37; }
    .note.miss { border-color: #b42318; }
    .note.skipped { border-color: #ff9900; opacity: 0.7; }
    .note.next { border-width: 2px; }

    /* Guitar fretboard styles */
    .fretboard {
      position: relative;
      width: 100%;
      height: 420px;
      background: linear-gradient(to bottom, #2a2a2a 0%, #1a1a1a 100%);
      border-radius: 8px;
      overflow: hidden;
      margin-top: 12px;
    }

    .string {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #888;
      border-radius: 1px;
    }

    .string.e-high { top: 45px; }
    .string.b { top: 105px; }
    .string.g { top: 165px; }
    .string.d { top: 225px; }
    .string.a { top: 285px; }
    .string.e-low { top: 345px; }

    .hit-zone {
      position: absolute;
      left: 60px;
      top: 0;
      bottom: 0;
      width: 4px;
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
      z-index: 10;
      transition: all 0.2s ease;
    }

    .hit-zone.hit-feedback {
      background: #00ff00;
      box-shadow: 0 0 30px #00ff00, 0 0 60px #00ff00;
      width: 8px;
      transform: scaleY(1.2);
    }

    .hit-zone.miss-feedback {
      background: #ff4444;
      box-shadow: 0 0 30px #ff4444, 0 0 60px #ff4444;
      width: 8px;
      transform: scaleY(1.2);
    }

    .hit-zone.skip-feedback {
      background: #ff9900;
      box-shadow: 0 0 20px #ff9900, 0 0 40px #ff9900;
      width: 6px;
      transform: scaleY(1.1);
    }

    /* Full-screen feedback overlay */
    .feedback-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    .feedback-overlay.hit {
      background: radial-gradient(circle, rgba(26, 127, 55, 0.3) 0%, rgba(26, 127, 55, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    .feedback-overlay.miss {
      background: radial-gradient(circle, rgba(180, 35, 24, 0.3) 0%, rgba(180, 35, 24, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    /* Enhanced fret note feedback */
    .fret-note.hit {
      background: #1a7f37;
      box-shadow: 0 0 25px #1a7f37, 0 0 50px #1a7f37;
      transform: translateY(-50%) scaleY(1.3);
      border-color: #00ff00;
      border-width: 3px;
    }

    .fret-note.miss {
      background: #b42318;
      box-shadow: 0 0 25px #b42318, 0 0 50px #b42318;
      transform: translateY(-50%) scaleY(1.3);
      border-color: #ff4444;
      border-width: 3px;
    }

    .fret-note.skipped {
      background: #ff9900;
      box-shadow: 0 0 15px #ff9900, 0 0 30px #ff9900;
      transform: translateY(-50%) scaleY(1.1);
      border-color: #ffaa33;
      border-width: 2px;
      opacity: 0.7;
    }

    .fret-note {
      position: absolute;
      min-width: 80px;
      height: 56px;
      border-radius: 16px;
      border: 5px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 900;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      color: #000;
      background: linear-gradient(145deg, #ffffff, #f0f0f0);
      transform: translateY(-50%);
      transition: none;
      z-index: 5;
      box-sizing: border-box;
      text-shadow:
        1px 1px 2px rgba(255,255,255,0.9),
        -1px -1px 2px rgba(255,255,255,0.9),
        2px 2px 4px rgba(0,0,0,0.3);
      box-shadow:
        0 0 0 2px #333,
        0 6px 20px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.8);
      will-change: transform;
      /* Anti-motion-blur techniques */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: geometricPrecision;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform-style: preserve-3d;
      /* Force hardware acceleration for smoother movement */
      -webkit-transform: translateZ(0) translateY(-50%);
      transform: translateZ(0) translateY(-50%);
      /* Prevent subpixel rendering issues and ensure crisp text */
      -webkit-transform: translate3d(0, -50%, 0);
      transform: translate3d(0, -50%, 0);
      /* Snap to pixel boundaries for crisp rendering */
      image-rendering: crisp-edges;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-optimize-contrast;
      /* Ensure text stays sharp during animation */
      -webkit-font-feature-settings: "liga" 0;
      font-feature-settings: "liga" 0;
    }

    .fret-note.open-string {
      background: linear-gradient(145deg, #9370db, #6a5acd);
      color: #fff;
      border-color: #4b0082;
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .fret-note.hit {
      background: linear-gradient(145deg, #22c55e, #16a34a);
      color: #fff;
      border-color: #15803d;
      box-shadow:
        0 0 0 2px #15803d,
        0 0 25px #22c55e,
        0 6px 20px rgba(0,0,0,0.4);
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .fret-note.miss {
      background: linear-gradient(145deg, #ef4444, #dc2626);
      color: #fff;
      border-color: #b91c1c;
      box-shadow:
        0 0 0 2px #b91c1c,
        0 0 25px #ef4444,
        0 6px 20px rgba(0,0,0,0.4);
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    /* Chord grouping styles */
    .chord-group {
      position: absolute;
      background: rgba(100, 150, 255, 0.1);
      border: 2px dashed rgba(100, 150, 255, 0.4);
      border-radius: 12px;
      z-index: 2;
      pointer-events: none;
      transition: all 0.2s ease;
    }

    .chord-group.hit {
      background: rgba(26, 127, 55, 0.2);
      border-color: rgba(26, 127, 55, 0.6);
    }

    .chord-group.miss {
      background: rgba(180, 35, 24, 0.2);
      border-color: rgba(180, 35, 24, 0.6);
    }

    .chord-group.skipped {
      background: rgba(255, 153, 0, 0.2);
      border-color: rgba(255, 153, 0, 0.6);
    }

    .fret-note.chord-member {
      border-color: rgba(100, 150, 255, 0.6);
      box-shadow:
        0 0 0 2px rgba(100, 150, 255, 0.6),
        0 6px 20px rgba(0,0,0,0.4);
    }

    .string-label {
      position: absolute;
      left: 10px;
      transform: translateY(-50%);
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 3px #000;
    }

    .flash {
      outline: 3px solid #999;
      border-radius: 10px;
      padding: 4px 8px;
      display: inline-block;
    }

    progress { width: 100%; height: 18px; }
    .hint { opacity: 0.75; font-size: 13px; margin-top: 10px; line-height: 1.35; }
  </style>
</head>

<body>
  <h1>Tab Trainer (Single Notes)</h1>

  <!-- Technical Controls at Top -->
  <div class="panel" style="margin-bottom: 20px;">
    <div class="row">
      <button id="btnMic">Enable Mic</button>
      <button id="btnStart" disabled>Start</button>
      <button id="btnStop" disabled>Stop</button>
      <div class="mono" id="status" style="opacity:0.8;">‚Äî</div>
    </div>

    <div class="row" style="margin-top:16px; gap:32px; flex-wrap:wrap;">
      <!-- Exercise Controls -->
      <div style="min-width:200px;">
        <div style="margin-bottom:10px;">
          <label for="exercise">Exercise</label>
          <select id="exercise">
            <option value="">Loading exercises...</option>
          </select>
        </div>
      </div>

      <!-- MusicXML Upload -->
      <div style="min-width:300px;">
        <label>Upload MusicXML File</label>
        <div class="upload-section" id="uploadSection">
          <div>Drop a MusicXML file here or</div>
          <input type="file" id="musicxmlFile" accept=".mxl,.xml,.musicxml" />
          <div class="upload-status" id="uploadStatus"></div>
        </div>
      </div>

      <!-- Tempo Controls -->
      <div style="min-width:220px;">
        <label for="bpm">BPM</label>
        <div class="row" style="gap:10px;">
          <input id="bpm" type="range" min="40" max="200" value="90" />
          <input id="bpmNum" type="number" min="40" max="200" value="90" style="width:90px;" />
        </div>
        <div style="margin-top:10px;">
          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="metroOn" type="checkbox" checked />
            Metronome
          </label>
          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="countInOn" type="checkbox" checked />
            4-beat count-in
          </label>
        </div>
      </div>

      <!-- FFT Chord Calibration -->
      <div style="min-width:200px;">
        <label for="fftThreshold">FFT Energy Threshold (dB)</label>
        <div class="row" style="gap:10px;">
          <input id="fftThreshold" type="range" min="-60" max="-20" value="-40" step="1" />
          <input id="fftThresholdNum" type="number" min="-60" max="-20" value="-40" step="1" style="width:70px;" />
        </div>
        <div style="margin-top:6px;">
          <label class="mono" style="display:flex; gap:6px; align-items:center; font-size:12px; margin-bottom:4px;">
            <input id="adaptiveCalibration" type="checkbox" checked />
            Auto-calibrate threshold
          </label>
          <button id="resetCalibration" style="font-size:11px; padding:4px 8px; margin-bottom:4px;">Reset Learning</button>
          <div class="mono" style="font-size:11px; opacity:0.7;">
            Auto adjusts for your mic and playing style
          </div>
          <div id="fftStatus" class="mono" style="font-size:12px; margin-top:4px;">‚Äî</div>
        </div>
      </div>

      <!-- Microphone Status -->
      <div style="min-width:180px;">
        <div id="micStatus" class="mono" style="margin-bottom:6px;">Not enabled</div>
        <progress id="level" value="0" max="1" style="width:100%; margin-bottom:4px;"></progress>
        <div id="levelText" class="mono" style="font-size:12px;">rms=‚Äî</div>
      </div>

      <!-- Detection Status -->
      <div style="min-width:160px;">
        <div style="margin-bottom:4px;">
          <strong>Last Note:</strong>
          <div id="lastNote" class="mono" style="font-size:18px;">‚Äî</div>
        </div>
        <div id="now" class="mono" style="font-size:12px;">‚Äî</div>
      </div>

      <!-- Calibration Button -->
      <div style="min-width:140px;">
        <button id="btnCalibrate" style="font-size:16px; padding:12px; width:100%; margin-bottom:8px; background:#0066cc; color:white;">
          üé∏ Calibrate Hardware
        </button>
        <div id="calibrationStatus" class="mono" style="font-size:11px; text-align:center;">
          Not calibrated
        </div>
      </div>
    </div>
  </div>

  <!-- Calibration Modal -->
  <div id="calibrationModal" class="panel" style="display:none; position:fixed; top:50%; left:50%; transform:translate(-50%,-50%); z-index:1000; background:white; border:2px solid #007bff; box-shadow:0 4px 20px rgba(0,0,0,0.3); width:90%; max-width:500px;">
    <div style="text-align:center; padding:20px;">
      <h2 style="margin:0 0 16px 0; color:#007bff;">üé∏ Hardware Calibration</h2>
      <p style="margin:0 0 20px 0; font-size:14px; line-height:1.4;">
        Play each open string clearly when prompted. This calibrates the detection system for your specific microphone and guitar.
      </p>

      <div id="calibrationStep" style="margin:20px 0;">
        <div id="calibrationInstruction" style="font-size:18px; font-weight:bold; margin-bottom:12px;">
          Ready to start calibration
        </div>
        <div id="calibrationProgress" style="background:#f0f0f0; border-radius:10px; height:20px; margin:12px 0;">
          <div id="calibrationProgressBar" style="background:#007bff; height:100%; border-radius:10px; width:0%; transition:width 0.3s;"></div>
        </div>
        <div id="calibrationDetails" class="mono" style="font-size:12px; color:#666;">
          6 strings to calibrate: E(6) - A(5) - D(4) - G(3) - B(2) - E(1)
        </div>
      </div>

      <div id="calibrationResults" style="display:none; margin:20px 0; padding:16px; background:#f8f9fa; border-radius:8px;">
        <h4 style="margin:0 0 12px 0;">Calibration Results</h4>
        <div id="calibrationSummary" class="mono" style="font-size:12px;">
          <!-- Results will be populated here -->
        </div>
      </div>

      <div style="margin-top:20px;">
        <button id="startCalibration" style="font-size:16px; padding:10px 20px; margin-right:10px; background:#1a7f37; color:white;">
          Start Calibration
        </button>
        <button id="skipCalibration" style="font-size:16px; padding:10px 20px; margin-right:10px;">
          Skip (Use Defaults)
        </button>
        <button id="closeCalibration" style="font-size:16px; padding:10px 20px;" disabled>
          Continue to Practice
        </button>
      </div>
    </div>
  </div>

  <!-- Calibration Overlay -->
  <div id="calibrationOverlay" style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.5); z-index:999;"></div>

  <!-- Main Fretboard Display -->
  <div class="panel" style="width: 100%; margin-bottom: 12px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <div class="big">Guitar Fretboard</div>
      <div id="scoreDisplay" style="display: flex; gap: 20px; font-size: 18px; font-weight: bold;">
        <div style="color: #1a7f37;">‚úì <span id="successCount">0</span></div>
        <div style="color: #b42318;">‚úó <span id="failCount">0</span></div>
        <div style="color: #ff9900;">‚äù <span id="skippedCount">0</span></div>
        <div style="color: #666;">Accuracy: <span id="accuracy">0%</span></div>
      </div>
    </div>

    <div class="fretboard" id="fretboard">
      <!-- String lines -->
      <div class="string e-high"></div>
      <div class="string b"></div>
      <div class="string g"></div>
      <div class="string d"></div>
      <div class="string a"></div>
      <div class="string e-low"></div>

      <!-- String labels -->
      <div class="string-label" style="top: 45px;">E</div>
      <div class="string-label" style="top: 105px;">B</div>
      <div class="string-label" style="top: 165px;">G</div>
      <div class="string-label" style="top: 225px;">D</div>
      <div class="string-label" style="top: 285px;">A</div>
      <div class="string-label" style="top: 345px;">E</div>

      <!-- Hit zone -->
      <div class="hit-zone"></div>
    </div>

    <!-- Fallback notes display for debugging (hidden by default) -->
    <div id="notes" class="notes" style="margin-top:12px; display: none;"></div>

    <div class="hint">
      Notes move from right to left. Play them when the left edge reaches the green line.
    </div>
  </div>

  <!-- Debug Info (Collapsible) -->
  <details class="panel" style="margin-top: 12px;">
    <summary style="cursor: pointer; font-weight: bold;">Debug Information</summary>
    <div style="margin-top: 12px;">
      <div id="lastNoteMeta" class="mono" style="opacity:0.8; font-size:12px; margin-bottom:8px;">‚Äî</div>

      <!-- Enhanced Debug Log -->
      <div style="margin-top: 12px;">
        <div style="font-weight: bold; margin-bottom: 8px;">Debug Log (all events):</div>
        <div id="debugLog" class="mono" style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 8px; font-size: 10px; max-height: 200px; overflow-y: auto;">
          <div style="opacity: 0.6;">Debug information will appear here when notes are played...</div>
        </div>
        <button id="clearDebug" style="margin-top: 8px; padding: 4px 8px; font-size: 12px;">Clear Log</button>
        <button id="copyDebug" style="margin-top: 8px; margin-left: 8px; padding: 4px 8px; font-size: 12px;">Copy to Clipboard</button>
      </div>

      <div class="hint" style="margin-top: 12px;">
        Debug tip: pluck one string cleanly (open A or D) and let it ring.
        Low E can be harder to detect.
      </div>
    </div>
  </details>

  <!-- Practice History -->
  <details class="panel" style="margin-top: 12px;">
    <summary style="cursor: pointer; font-weight: bold;">Practice History</summary>
    <div style="margin-top: 12px;">
      <div id="practiceHistory" style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 8px; font-size: 12px; max-height: 300px; overflow-y: auto;">
        <div style="opacity: 0.6; text-align: center; padding: 20px;">No practice sessions yet. Complete an exercise to see your history!</div>
      </div>
      <button id="clearHistory" style="margin-top: 8px; padding: 4px 8px; font-size: 12px;">Clear History</button>
    </div>
  </details>

  <!-- Full-screen feedback overlay -->
  <div id="feedbackOverlay" class="feedback-overlay"></div>

<script>
/**
 * -------------------------
 * Exercise management
 * -------------------------
 */
let availableExercises = [];
let currentExercise = null;

// Default fallback exercise (same as original hardcoded)
const defaultExercise = {
  name: "Basic Strings",
  description: "Learn the open strings: E-A-D-G-B-E",
  bpm: 90,
  difficulty: "beginner",
  notes: [
    { beat: 0, midi: 40 }, // E2
    { beat: 1, midi: 45 }, // A2
    { beat: 2, midi: 50 }, // D3
    { beat: 3, midi: 55 }, // G3
    { beat: 4, midi: 59 }, // B3
    { beat: 5, midi: 64 }, // E4
  ]
};

// For backward compatibility
const song = defaultExercise.notes;

async function loadAvailableExercises() {
  try {
    const exerciseFiles = ['basic-strings.json', 'chromatic-scale.json', 'simple-melody.json', 'house-of-rising-sun.json'];
    availableExercises = [];

    // Add metronome-only option
    const metronomeOnlyExercise = {
      name: "Metronome Only",
      description: "Just metronome clicks, no tabs",
      bpm: 90,
      difficulty: "metronome",
      notes: [],
      fileName: "metronome-only"
    };
    availableExercises.push(metronomeOnlyExercise);

    for (const fileName of exerciseFiles) {
      try {
        const response = await fetch(`exercises/${fileName}?v=${Date.now()}`);
        if (response.ok) {
          const exercise = await response.json();
          exercise.fileName = fileName;
          availableExercises.push(exercise);
        } else {
          console.warn(`Failed to load exercise: ${fileName}`);
        }
      } catch (e) {
        console.warn(`Error loading exercise ${fileName}:`, e);
      }
    }

    // Use default exercise if no exercises were loaded (besides metronome-only)
    if (availableExercises.length === 1) { // Only metronome option
      availableExercises.push(defaultExercise);
    }

    populateExerciseDropdown();
    loadExercise(availableExercises[0]);
  } catch (e) {
    console.error('Failed to load exercises:', e);
    // Fallback to default exercise
    availableExercises = [defaultExercise];
    populateExerciseDropdown();
    loadExercise(defaultExercise);
  }
}

function populateExerciseDropdown() {
  const select = $("exercise");
  select.innerHTML = "";

  for (const exercise of availableExercises) {
    const option = document.createElement("option");
    option.value = exercise.fileName || "default";
    option.textContent = `${exercise.name} (${exercise.difficulty})`;
    select.appendChild(option);
  }
}

function loadExercise(exercise) {
  currentExercise = exercise;

  // Update the global song array for backward compatibility
  song.length = 0;
  song.push(...exercise.notes);

  // Update BPM if specified
  if (exercise.bpm) {
    setBpm(exercise.bpm);
  }

  // Reset the practice session
  if (state.practicing) {
    $("btnStop").click();
  }
  resetPractice();

  console.log(`Loaded exercise: ${exercise.name} (${exercise.notes.length} notes)`);
}

/**
 * -------------------------
 * Tuning knobs (MVP)
 * -------------------------
 */
const MIN_RMS = 0.003;       // gate for "is there sound?"
const STABLE_FRAMES = 2;     // require stable MIDI rounding for N frames
const CENTS_TOLERANCE = 40;  // pitch forgiveness
const COOLDOWN_SEC = 0.25;   // prevent double triggers on one note (reduced for slow tempos)
const DEFAULT_BPM = 90;
const BEATS_PER_BAR = 4;

/**
 * -------------------------
 * Guitar fretboard constants
 * -------------------------
 */
const TUNING = [40, 45, 50, 55, 59, 64]; // MIDI values for standard tuning (E-A-D-G-B-E)
const STRING_NAMES = ["E", "A", "D", "G", "B", "E"];
const STRING_POSITIONS = [345, 285, 225, 165, 105, 45]; // Y positions for each string
const LOOKAHEAD_BEATS = 4;   // notes appear 4 beats early
const HIT_ZONE_X = 60;       // X position of hit zone
let NOTE_TRAVEL_DISTANCE = 800; // will be calculated dynamically
const MAX_FRET = 12;         // maximum fret to consider

const $ = (id) => document.getElementById(id);

function calculateTravelDistance() {
  const fretboard = $("fretboard");
  if (fretboard) {
    const fretboardWidth = fretboard.offsetWidth;
    NOTE_TRAVEL_DISTANCE = fretboardWidth - HIT_ZONE_X - 40; // 40px padding from right edge
  }
}

function midiToName(midi) {
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const n = names[midi % 12];
  const oct = Math.floor(midi/12) - 1;
  return `${n}${oct}`;
}
function freqToMidi(freq) {
  return 69 + 12 * Math.log2(freq / 440);
}
function midiToFreq(midi) {
  return 440 * Math.pow(2, (midi - 69) / 12);
}
function centsDiff(midiFloat, midiInt) {
  return (midiFloat - midiInt) * 100;
}
function secondsToBeats(seconds, bpm) {
  return (seconds * bpm) / 60;
}
function beatsToSeconds(beats, bpm) {
  return (beats * 60) / bpm;
}

/**
 * Convert MIDI note to guitar string and fret position
 * Returns { string: index, fret: number, y: pixel position } or null if unplayable
 */
function midiToFret(midiNote) {
  const candidates = [];

  // Check each string for possible fret positions
  for (let stringIdx = 0; stringIdx < TUNING.length; stringIdx++) {
    const openStringMidi = TUNING[stringIdx];
    const fret = midiNote - openStringMidi;

    // Must be a valid fret (0-MAX_FRET)
    if (fret >= 0 && fret <= MAX_FRET) {
      candidates.push({
        string: stringIdx,
        fret: fret,
        y: STRING_POSITIONS[stringIdx],
        stringName: STRING_NAMES[stringIdx]
      });
    }
  }

  if (candidates.length === 0) return null;

  // Prefer lower frets for easier playability
  // If multiple options, choose the one with lowest fret number
  candidates.sort((a, b) => a.fret - b.fret);
  return candidates[0];
}

/**
 * Timing window that adapts to tempo.
 * Wider at slow BPM so practice doesn't feel punishing.
 */
function timingWindowBeats(bpm) {
  // ~0.60 beats at 40 BPM, ~0.25 beats at 120 BPM, floor at 0.20
  return Math.max(0.20, Math.min(0.60, (120 / bpm) * 0.25));
}

/**
 * -------------------------
 * YIN pitch detector (monophonic)
 * -------------------------
 */
function yinPitch(buffer, sampleRate) {
  let rms = 0;
  for (let i = 0; i < buffer.length; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms / buffer.length);
  if (rms < MIN_RMS) return { freq: null, conf: 0, rms };

  const threshold = 0.12;
  const bufferSize = buffer.length;
  const maxTau = Math.floor(sampleRate / 50);
  const minTau = Math.floor(sampleRate / 1000);

  const d = new Float32Array(maxTau + 1);
  for (let tau = minTau; tau <= maxTau; tau++) {
    let sum = 0;
    const maxI = Math.max(0, bufferSize - tau);
    for (let i = 0; i < maxI; i++) {
      const delta = buffer[i] - buffer[i + tau];
      sum += delta * delta;
    }
    d[tau] = sum;
  }

  const cmndf = new Float32Array(maxTau + 1);
  cmndf[0] = 1;
  let runningSum = 0;
  for (let tau = 1; tau <= maxTau; tau++) {
    runningSum += d[tau];
    cmndf[tau] = runningSum === 0 ? 1 : d[tau] * tau / runningSum;
  }

  let tauEstimate = -1;
  for (let tau = minTau; tau <= maxTau; tau++) {
    if (tau < cmndf.length && cmndf[tau] < threshold) {
      while (tau + 1 <= maxTau && tau + 1 < cmndf.length && cmndf[tau + 1] < cmndf[tau]) tau++;
      tauEstimate = tau;
      break;
    }
  }
  if (tauEstimate === -1 || tauEstimate >= cmndf.length) return { freq: null, conf: 0, rms };

  // Parabolic interpolation
  const x0 = tauEstimate > 1 ? tauEstimate - 1 : tauEstimate;
  const x2 = tauEstimate + 1 <= maxTau && tauEstimate + 1 < cmndf.length ? tauEstimate + 1 : tauEstimate;

  const s0 = x0 < cmndf.length ? cmndf[x0] : 1;
  const s1 = tauEstimate < cmndf.length ? cmndf[tauEstimate] : 1;
  const s2 = x2 < cmndf.length ? cmndf[x2] : 1;

  const a = (s0 + s2 - 2 * s1) / 2;
  const b = (s2 - s0) / 2;
  const betterTau = (Math.abs(a) > 1e-10) ? (tauEstimate - b / (2 * a)) : tauEstimate;

  const freq = sampleRate / betterTau;
  const conf = Math.max(0, Math.min(1, 1 - cmndf[tauEstimate]));
  return { freq, conf, rms };
}

/**
 * -------------------------
 * FFT Chord Detection (Polyphonic)
 * -------------------------
 */
function detectChord(analyser, targetNotes, sampleRate) {
  try {
    const bufferLength = analyser.frequencyBinCount;
    const dataArray = new Float32Array(bufferLength);
    analyser.getFloatFrequencyData(dataArray);

    // Calculate frequency resolution (Hz per bin)
    const nyquist = sampleRate / 2;
    const freqPerBin = nyquist / bufferLength;

    // Energy threshold for detection (in dB) - more aggressive for chords
    let ENERGY_THRESHOLD;
    if (state.hardwareCalibration.isCalibrated && state.hardwareCalibration.quality > 0.3) {
      ENERGY_THRESHOLD = state.hardwareCalibration.optimalThreshold;
    } else if (state.adaptiveCalibration.enabled && state.adaptiveCalibration.confidence > 0.3) {
      ENERGY_THRESHOLD = state.adaptiveCalibration.adaptiveThreshold;
    } else {
      ENERGY_THRESHOLD = parseFloat($("fftThreshold").value || -40);
    }

    // Extremely aggressive threshold for chord detection - detect very weak signals
    ENERGY_THRESHOLD = ENERGY_THRESHOLD - 50; // 50dB more sensitive for chords

    console.log("üéµ FFT DEBUG: Energy threshold:", ENERGY_THRESHOLD, "dB");

    let detectedCount = 0;
    const detectedNotes = [];

    // Quick exit if no notes to detect
    if (!targetNotes || targetNotes.length === 0) {
      return {
        success: false,
        detectedCount: 0,
        requiredCount: 0,
        detectedNotes: [],
        confidence: 0,
        majorityThreshold: 0
      };
    }

    for (const noteData of targetNotes) {
      try {
        const targetMidi = noteData.midi;
        const fundamentalFreq = midiToFreq(targetMidi);
        const harmonicFreq = fundamentalFreq * 2; // 2nd harmonic for low frequency handling

        // Find corresponding FFT bins with wider search window
        const fundamentalBin = Math.round(fundamentalFreq / freqPerBin);
        const harmonicBin = Math.round(harmonicFreq / freqPerBin);

        // Check if bins are within valid range
        const fundamentalInRange = fundamentalBin >= 0 && fundamentalBin < bufferLength;
        const harmonicInRange = harmonicBin >= 0 && harmonicBin < bufferLength;

        let fundamentalEnergy = -Infinity;
        let harmonicEnergy = -Infinity;

        // Get energy from fundamental frequency (with wider tolerance)
        if (fundamentalInRange) {
          const startBin = Math.max(0, fundamentalBin - 2); // Wider search window
          const endBin = Math.min(bufferLength - 1, fundamentalBin + 2);
          for (let i = startBin; i <= endBin; i++) {
            if (i < dataArray.length) {
              fundamentalEnergy = Math.max(fundamentalEnergy, dataArray[i]);
            }
          }
        }

        // Get energy from 2nd harmonic (for low-frequency handling)
        if (harmonicInRange) {
          const startBin = Math.max(0, harmonicBin - 2); // Wider search window
          const endBin = Math.min(bufferLength - 1, harmonicBin + 2);
          for (let i = startBin; i <= endBin; i++) {
            if (i < dataArray.length) {
              harmonicEnergy = Math.max(harmonicEnergy, dataArray[i]);
            }
          }
        }

        // Note is detected if either fundamental OR harmonic is above threshold
        const detected = fundamentalEnergy > ENERGY_THRESHOLD || harmonicEnergy > ENERGY_THRESHOLD;

        console.log(`üéµ FFT DEBUG: Note ${midiToName(targetMidi)} (${fundamentalFreq.toFixed(1)}Hz) - Fundamental: ${fundamentalEnergy.toFixed(1)}dB, Harmonic: ${harmonicEnergy.toFixed(1)}dB, Threshold: ${ENERGY_THRESHOLD.toFixed(1)}dB, Detected: ${detected}`);

        if (detected) {
          detectedCount++;
          detectedNotes.push({
            midi: targetMidi,
            freq: fundamentalFreq,
            fundamentalEnergy,
            harmonicEnergy,
            usedHarmonic: harmonicEnergy > fundamentalEnergy
          });
        }
      } catch (noteError) {
        console.warn("Error processing note in chord detection:", noteError);
        // Continue processing other notes
      }
    }

    // Much more lenient success criteria - any single chord tone counts as success
    const minimumThreshold = 1; // Any single chord tone is enough
    const strongThreshold = Math.max(2, Math.ceil(targetNotes.length * 0.5)); // 50% for strong detection
    const anyDetected = detectedCount >= minimumThreshold;

    console.log(`üéµ FFT DEBUG: Detected ${detectedCount}/${targetNotes.length} chord tones (need ${minimumThreshold}+), success: ${anyDetected}`);

    return {
      success: anyDetected,
      detectedCount,
      requiredCount: targetNotes.length,
      detectedNotes,
      confidence: detectedCount / targetNotes.length, // 0.0 to 1.0
      majorityThreshold: minimumThreshold,
      isStrong: detectedCount >= strongThreshold
    };

  } catch (error) {
    console.error("FFT chord detection error:", error);
    // Return safe fallback
    return {
      success: false,
      detectedCount: 0,
      requiredCount: targetNotes ? targetNotes.length : 0,
      detectedNotes: [],
      confidence: 0,
      majorityThreshold: 0,
      error: error.message
    };
  }
}

/**
 * -------------------------
 * Hybrid Detection System
 * -------------------------
 */
function hybridDetection(analyser, timeDomainBuffer, sampleRate, expectedEvent) {
  try {
    // Enhanced hybrid detection with safety checks
    if (!expectedEvent) {
      // No expected notes, fall back to YIN
      console.log("üîç HYBRID DEBUG: No expected event, using YIN");
      const yinResult = yinPitch(timeDomainBuffer, sampleRate);
      return { method: 'yin', result: yinResult };
    }

    // Debug log the expected event structure
    console.log("üîç HYBRID DEBUG: Expected event:", {
      type: expectedEvent ? expectedEvent.type : 'null',
      hasNotes: expectedEvent ? !!expectedEvent.notes : false,
      notesLength: expectedEvent && expectedEvent.notes ? expectedEvent.notes.length : 0,
      beat: expectedEvent ? expectedEvent.beat : 'null',
      midi: expectedEvent ? expectedEvent.midi : 'null'
    });

    if (expectedEvent.type === "chord" && expectedEvent.notes && expectedEvent.notes.length > 1) {
      // Chord expected: use FFT detection with graceful fallback
      console.log("üéµ HYBRID DEBUG: Using FFT for chord detection, target notes:", expectedEvent.notes.length);
      try {
        const chordResult = detectChord(analyser, expectedEvent.notes, sampleRate);
        console.log("üéµ HYBRID DEBUG: FFT result:", chordResult);

        // Always return FFT result, even if not successful - let the main logic decide
        return { method: 'fft', result: chordResult };
      } catch (fftError) {
        console.warn("FFT chord detection failed, falling back to YIN:", fftError);
        const yinResult = yinPitch(timeDomainBuffer, sampleRate);
        return { method: 'yin-fallback', result: yinResult };
      }
    } else {
      // Single note expected: use YIN for precision
      console.log("üîç HYBRID DEBUG: Using YIN for single note");
      const yinResult = yinPitch(timeDomainBuffer, sampleRate);
      return { method: 'yin', result: yinResult };
    }
  } catch (error) {
    console.error("Hybrid detection error:", error);
    // Ultimate fallback to ensure animation never stops
    const yinResult = yinPitch(timeDomainBuffer, sampleRate);
    return { method: 'yin-error-fallback', result: yinResult };
  }
}

/**
 * Helper function to get the current expected event based on timing window
 */
function getCurrentExpectedEvent(beatNow) {
  const win = timingWindowBeats(state.bpm);
  let closestEvent = null;
  let closestDistance = Infinity;

  for (const ev of state.events) {
    if (ev.hit) continue; // Skip already hit notes

    const distance = Math.abs(beatNow - ev.beat);
    if (distance <= win && distance < closestDistance) {
      closestDistance = distance;
      closestEvent = ev;
    }
  }

  // Debug log when we find an expected event (only for chords to reduce spam)
  if (closestEvent && closestEvent.type === "chord") {
    console.log("üéØ EXPECTED EVENT DEBUG:", {
      beat: beatNow.toFixed(2),
      window: win.toFixed(3),
      foundEvent: {
        type: closestEvent.type,
        beat: closestEvent.beat,
        midi: closestEvent.midi,
        hasNotes: !!closestEvent.notes,
        notesLength: closestEvent.notes ? closestEvent.notes.length : 0
      }
    });
  }

  return closestEvent;
}

/**
 * Octave correction: if detector locks on a harmonic (octave up/down),
 * choose the octave variant closest to expected MIDI.
 */
function octaveCorrect(playedFreq, expectedMidi) {
  const playedMidi = freqToMidi(playedFreq);
  const candidates = [
    playedMidi,
    playedMidi - 12,
    playedMidi + 12,
  ];

  let best = candidates[0];
  let bestAbs = Math.abs(centsDiff(candidates[0], expectedMidi));
  for (const c of candidates) {
    const a = Math.abs(centsDiff(c, expectedMidi));
    if (a < bestAbs) { bestAbs = a; best = c; }
  }
  return { correctedMidi: best, centsOff: centsDiff(best, expectedMidi) };
}

/**
 * -------------------------
 * Visual notes management
 * -------------------------
 */
function clearVisualNotes() {
  for (const [noteId, noteData] of state.visualNotes) {
    if (noteData.element && noteData.element.parentNode) {
      noteData.element.remove();
    }
  }
  state.visualNotes.clear();
  state.nextNoteId = 0;
}

function createVisualNote(eventData, fretInfo) {
  const noteId = state.nextNoteId++;
  const fretboard = $("fretboard");

  // Check if this is a chord event
  if (eventData.type === "chord") {
    return createVisualChord(eventData, noteId);
  }

  // Single note logic (existing)
  const noteElement = document.createElement("div");
  noteElement.className = "fret-note";

  // Use fretInfo if provided, otherwise derive from MIDI
  const actualFretInfo = fretInfo || midiToFret(eventData.midi);
  if (!actualFretInfo) return null;

  // Make open strings (fret 0) more distinguishable
  if (actualFretInfo.fret === 0) {
    noteElement.textContent = "O"; // Use "O" instead of "0" for open strings
    noteElement.style.fontSize = "20px"; // Slightly smaller for the "O"
    noteElement.classList.add("open-string");
  } else {
    noteElement.textContent = actualFretInfo.fret.toString();
  }

  // Calculate note duration for width
  const currentEventIndex = state.events.findIndex(e => e === eventData);
  let noteDuration = 1.0; // Default duration in beats

  if (currentEventIndex >= 0 && currentEventIndex < state.events.length - 1) {
    const nextEvent = state.events[currentEventIndex + 1];
    noteDuration = nextEvent.beat - eventData.beat;
  }

  // Convert duration to pixel width (scale it appropriately)
  const baseWidth = 80; // minimum width (matches min-width in CSS)
  const widthPerBeat = 100; // pixels per beat (increased for larger, more readable notes)
  const noteWidth = Math.max(baseWidth, noteDuration * widthPerBeat);

  noteElement.style.width = noteWidth + "px";

  // Start position (rightmost edge of fretboard) - using transform for better performance
  const startX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE;
  noteElement.style.left = "0px"; // Keep at origin for transform calculations
  noteElement.style.top = actualFretInfo.y + "px";
  noteElement.style.transform = `translate3d(${startX}px, -50%, 0)`;

  fretboard.appendChild(noteElement);

  const noteData = {
    element: noteElement,
    eventData: eventData,
    fretInfo: actualFretInfo,
    noteId: noteId,
    spawned: false,
    duration: noteDuration,
    feedbackShown: false
  };

  state.visualNotes.set(noteId, noteData);
  return noteData;
}

function createVisualChord(eventData, baseNoteId) {
  const fretboard = $("fretboard");
  const chordElements = [];
  const chordNoteData = [];

  // Calculate note duration for width
  const currentEventIndex = state.events.findIndex(e => e === eventData);
  let noteDuration = 1.0; // Default duration in beats

  if (currentEventIndex >= 0 && currentEventIndex < state.events.length - 1) {
    const nextEvent = state.events[currentEventIndex + 1];
    noteDuration = nextEvent.beat - eventData.beat;
  }

  const baseWidth = 80;
  const widthPerBeat = 100;
  const noteWidth = Math.max(baseWidth, noteDuration * widthPerBeat);
  const startX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE;

  // Create a chord container that will hold both the background and notes
  const chordContainer = document.createElement("div");
  chordContainer.className = "chord-container";
  chordContainer.style.position = "absolute";
  chordContainer.style.left = "0px";
  chordContainer.style.top = "0px";
  chordContainer.style.transform = `translate3d(${startX}px, 0, 0)`;
  chordContainer.style.pointerEvents = "none";

  // Create visual elements for each chord tone
  let minY = Infinity, maxY = -Infinity;
  for (let i = 0; i < eventData.notes.length; i++) {
    const chordNote = eventData.notes[i];
    const noteId = baseNoteId + i * 0.1; // Ensure unique IDs

    // Get fret info - use from MusicXML if available, otherwise calculate
    let fretInfo;
    if (chordNote.string && chordNote.fret !== undefined) {
      // Use MusicXML tablature info directly
      const STRING_POSITIONS = [345, 285, 225, 165, 105, 45]; // positions for strings 6-1
      const STRING_NAMES = ["E", "A", "D", "G", "B", "E"];
      fretInfo = {
        string: chordNote.string - 1, // Convert 1-based to 0-based
        fret: chordNote.fret,
        y: STRING_POSITIONS[6 - chordNote.string], // Convert 1-based to position array
        stringName: STRING_NAMES[6 - chordNote.string]
      };
    } else {
      // Fallback to MIDI-based calculation
      fretInfo = midiToFret(chordNote.midi);
    }

    if (!fretInfo) continue;

    // Create note element
    const noteElement = document.createElement("div");
    noteElement.className = "fret-note chord-member";

    if (fretInfo.fret === 0) {
      noteElement.textContent = "O";
      noteElement.style.fontSize = "20px";
      noteElement.classList.add("open-string");
    } else {
      noteElement.textContent = fretInfo.fret.toString();
    }

    noteElement.style.width = noteWidth + "px";
    noteElement.style.left = "0px";
    noteElement.style.top = fretInfo.y + "px";
    noteElement.style.transform = `translate3d(0px, -50%, 0)`; // No X translation, container handles it

    chordContainer.appendChild(noteElement);
    chordElements.push(noteElement);

    // Track Y bounds for chord group background
    minY = Math.min(minY, fretInfo.y);
    maxY = Math.max(maxY, fretInfo.y);

    const noteData = {
      element: noteElement,
      eventData: eventData,
      fretInfo: fretInfo,
      noteId: noteId,
      spawned: false,
      duration: noteDuration,
      feedbackShown: false,
      chordIndex: i,
      isChordMember: true,
      container: chordContainer
    };

    chordNoteData.push(noteData);
    state.visualNotes.set(noteId, noteData);
  }

  // Create chord group background within the container
  if (chordElements.length > 1) {
    const chordGroup = document.createElement("div");
    chordGroup.className = "chord-group";

    // Calculate proper dimensions and position relative to container
    const groupHeight = maxY - minY + 70; // Add padding for note height
    const groupWidth = noteWidth + 24; // Add padding for note width

    // Position the group within the container (no transform needed)
    const groupTop = minY - 35; // Center vertically on the notes

    chordGroup.style.width = groupWidth + "px";
    chordGroup.style.height = groupHeight + "px";
    chordGroup.style.left = "-12px"; // Just a bit left of notes to encompass them properly
    chordGroup.style.top = groupTop + "px";
    chordGroup.style.transform = "none"; // No transform needed, positioned relative to container

    chordContainer.appendChild(chordGroup);

    // Store reference to chord group in all chord members
    chordNoteData.forEach(noteData => {
      noteData.chordGroup = chordGroup;
    });
  }

  // Add the container to the fretboard
  fretboard.appendChild(chordContainer);

  return chordNoteData[0]; // Return the first note for main tracking
}

function updateVisualNotes(beatNow) {
  const fretboard = $("fretboard");
  const notesToRemove = [];

  // Spawn new notes that should be visible (exactly at LOOKAHEAD_BEATS before hit time)
  for (const event of state.events) {
    if (!event.visualNote && beatNow >= event.beat - LOOKAHEAD_BEATS && !event.judged) {
      let noteData = null;

      if (event.type === "chord") {
        // Create chord visualization
        noteData = createVisualNote(event, null);
      } else {
        // Single note
        const fretInfo = midiToFret(event.midi);
        if (fretInfo) {
          noteData = createVisualNote(event, fretInfo);
        }
      }

      if (noteData) {
        event.visualNote = noteData;
        noteData.spawned = true;
      }
    }
  }

  // Update positions of existing notes
  for (const [noteId, noteData] of state.visualNotes) {
    const event = noteData.eventData;
    const timeToHit = event.beat - beatNow;

    // Calculate position based on remaining time
    const progress = (LOOKAHEAD_BEATS - timeToHit) / LOOKAHEAD_BEATS;
    // Position so left edge touches hit zone when timeToHit = 0
    const currentX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE * (1 - progress);

    // For chord members, animate the container instead of individual notes
    if (noteData.isChordMember && noteData.container) {
      if (noteData.chordIndex === 0) {
        // Only update container position from the first chord member
        noteData.container.style.transform = `translate3d(${currentX}px, 0, 0)`;
      }
      // Individual notes within chord don't need transform updates since they're relative to container
    } else {
      // Single notes use their own transform
      noteData.element.style.transform = `translate3d(${currentX}px, -50%, 0)`;
    }

    // Visual feedback is now handled immediately when notes are scored
    // No delayed feedback needed here

    // Update visual state based on hit/miss/skipped
    if (event.hit && !noteData.element.classList.contains("hit")) {
      noteData.element.classList.add("hit");
      // Update chord group feedback
      if (noteData.chordGroup) {
        noteData.chordGroup.classList.add("hit");
      }
    }
    if (event.miss && !noteData.element.classList.contains("miss")) {
      noteData.element.classList.add("miss");
      // Update chord group feedback
      if (noteData.chordGroup) {
        noteData.chordGroup.classList.add("miss");
      }
    }
    if (event.skipped && !noteData.element.classList.contains("skipped")) {
      noteData.element.classList.add("skipped");
      // Update chord group feedback
      if (noteData.chordGroup) {
        noteData.chordGroup.classList.add("skipped");
      }
    }

    // Remove notes that have passed the hit zone
    if (timeToHit < -1) { // 1 beat grace period after missing
      notesToRemove.push(noteId);
    }
  }

  // Clean up old notes
  for (const noteId of notesToRemove) {
    const noteData = state.visualNotes.get(noteId);
    if (noteData && noteData.element && noteData.element.parentNode) {
      noteData.element.remove();

      // Clean up chord group when removing the first chord member
      if (noteData.isChordMember && noteData.chordIndex === 0 && noteData.chordGroup && noteData.chordGroup.parentNode) {
        noteData.chordGroup.remove();
      }
    }
    state.visualNotes.delete(noteId);
  }
}

function updateScoreDisplay() {
  $("successCount").textContent = state.successCount;
  $("failCount").textContent = state.failCount;
  $("skippedCount").textContent = state.skippedCount;

  const total = state.successCount + state.failCount + state.skippedCount;
  const accuracy = total === 0 ? 0 : Math.round((state.successCount / total) * 100);
  $("accuracy").textContent = accuracy + "%";
}

function showHitZoneFeedback(isHit, isSkipped = false) {
  const hitZone = $("fretboard").querySelector(".hit-zone");

  // Remove any existing feedback classes
  hitZone.classList.remove("hit-feedback", "miss-feedback", "skip-feedback");

  // Add appropriate feedback class
  if (isHit) {
    hitZone.classList.add("hit-feedback");
  } else if (isSkipped) {
    hitZone.classList.add("skip-feedback");
  } else {
    hitZone.classList.add("miss-feedback");
  }

  // Remove feedback after animation
  setTimeout(() => {
    hitZone.classList.remove("hit-feedback", "miss-feedback", "skip-feedback");
  }, 300);
}

function addDebugEntry(entry) {
  const timestamp = new Date().toLocaleTimeString();
  const debugEntry = `[${timestamp}] ${entry}`;

  state.debugLog.push(debugEntry);

  // No limit - keep all entries
  updateDebugDisplay();
}

function updateDebugDisplay() {
  const debugLogElement = $("debugLog");
  if (debugLogElement) {
    debugLogElement.innerHTML = state.debugLog.join('<br>') || '<div style="opacity: 0.6;">No debug entries yet...</div>';
    debugLogElement.scrollTop = debugLogElement.scrollHeight;
  }
}

function clearDebugLog() {
  state.debugLog = [];
  updateDebugDisplay();
}

function copyDebugToClipboard() {
  const debugText = state.debugLog.join('\n');
  navigator.clipboard.writeText(debugText).then(() => {
    const btn = $("copyDebug");
    const originalText = btn.textContent;
    btn.textContent = "Copied!";
    setTimeout(() => {
      btn.textContent = originalText;
    }, 2000);
  }).catch(() => {
    alert("Copy failed. Debug text:\n\n" + debugText);
  });
}

function addPracticeHistoryEntry() {
  const timestamp = new Date().toLocaleString();
  const exerciseSelect = $("exercise");
  const exerciseName = exerciseSelect && exerciseSelect.selectedOptions.length > 0
    ? exerciseSelect.selectedOptions[0].text
    : "Unknown Exercise";

  const total = state.successCount + state.failCount + state.skippedCount;
  const accuracy = total === 0 ? 0 : Math.round((state.successCount / total) * 100);

  const historyEntry = {
    timestamp,
    exercise: exerciseName,
    bpm: state.bpm,
    hits: state.successCount,
    misses: state.failCount,
    skips: state.skippedCount,
    accuracy: accuracy,
    total: total
  };

  console.log('Adding practice history entry:', historyEntry);
  state.practiceHistory.push(historyEntry);
  console.log('Practice history now has', state.practiceHistory.length, 'entries');
  updatePracticeHistoryDisplay();
}

function updatePracticeHistoryDisplay() {
  const historyElement = $("practiceHistory");
  if (!historyElement) return;

  if (state.practiceHistory.length === 0) {
    historyElement.innerHTML = '<div style="opacity: 0.6; text-align: center; padding: 20px;">No practice sessions yet. Complete an exercise to see your history!</div>';
    return;
  }

  const historyHtml = state.practiceHistory.slice(-10).reverse().map(entry => {
    const accuracyColor = entry.accuracy >= 90 ? '#1a7f37' : entry.accuracy >= 70 ? '#ff9900' : '#b42318';
    return `
      <div style="border-bottom: 1px solid #ddd; padding: 8px 0; display: flex; justify-content: space-between; align-items: center;">
        <div>
          <div style="font-weight: bold; margin-bottom: 2px;">${entry.exercise}</div>
          <div style="font-size: 11px; opacity: 0.7;">${entry.timestamp}</div>
        </div>
        <div style="text-align: right;">
          <div style="font-weight: bold; color: ${accuracyColor};">${entry.accuracy}%</div>
          <div style="font-size: 11px;">${entry.bpm} BPM | ${entry.hits}‚úì ${entry.misses}‚úó ${entry.skips}‚äù</div>
        </div>
      </div>
    `;
  }).join('');

  historyElement.innerHTML = historyHtml;
  historyElement.scrollTop = 0; // Scroll to top to see latest
}

function clearPracticeHistory() {
  state.practiceHistory = [];
  updatePracticeHistoryDisplay();
}

function showFullScreenFeedback(isHit) {
  const overlay = $("feedbackOverlay");

  // Remove any existing feedback classes
  overlay.classList.remove("hit", "miss");

  // Add appropriate feedback class
  if (isHit) {
    overlay.classList.add("hit");
  } else {
    overlay.classList.add("miss");
  }

  // Remove feedback after animation
  setTimeout(() => {
    overlay.classList.remove("hit", "miss");
  }, 200);
}

/**
 * -------------------------
 * Rendering
 * -------------------------
 */
function renderNotes() {
  const root = $("notes");
  root.innerHTML = "";

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    const div = document.createElement("div");

    let cls = "note";
    if (i === state.nextIdx) cls += " next";
    if (ev.hit) cls += " hit";
    if (ev.miss) cls += " miss";
    if (ev.skipped) cls += " skipped";

    div.className = cls;

    // Handle chord vs single note display
    if (ev.type === "chord") {
      const chordTones = ev.notes.map(note => midiToName(note.midi)).join("+");
      div.innerHTML = `
        <div class="mono">[${chordTones}]</div>
        <div class="t mono">chord beat=${ev.beat.toFixed(2)}</div>
      `;
    } else {
      div.innerHTML = `
        <div class="mono">${midiToName(ev.midi)}</div>
        <div class="t mono">beat=${ev.beat.toFixed(2)}</div>
      `;
    }

    root.appendChild(div);
  }
}

/**
 * -------------------------
 * Matching logic
 * -------------------------
 */
function getNextUnhitIndex() {
  return state.events.findIndex(ev => !ev.hit && !ev.miss && !ev.skipped);
}

function judgeMisses(beatNow) {
  const win = timingWindowBeats(state.bpm);

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    if (!ev.judged && beatNow > ev.beat + win) {
      ev.judged = true;

      if (!ev.hit) {
        // Check if any input was attempted during this note's window
        const hadInputAttempt = state.inputAttemptedDuringWindow.has(i);

        if (hadInputAttempt) {
          // Wrong note was played
          ev.miss = true;
          state.failCount++;

          // Show miss feedback on hit zone
          showHitZoneFeedback(false, false);

          // Debug log for missed notes
          const expectedInfo = ev.type === "chord"
            ? `chord [${ev.notes.map(n => midiToName(n.midi)).join("+")}]`
            : midiToName(ev.midi);
          addDebugEntry(`‚ùå MISS: Expected ${expectedInfo} at beat ${ev.beat.toFixed(2)}, but wrong note was played during timing window`);
        } else {
          // No input at all - note was skipped
          ev.skipped = true;
          state.skippedCount++;

          // Show skip feedback on hit zone
          showHitZoneFeedback(false, true);

          // Debug log for skipped notes
          const expectedInfo = ev.type === "chord"
            ? `chord [${ev.notes.map(n => midiToName(n.midi)).join("+")}]`
            : midiToName(ev.midi);
          addDebugEntry(`‚äù SKIP: Expected ${expectedInfo} at beat ${ev.beat.toFixed(2)}, but no input detected during timing window`);
        }

        updateScoreDisplay();
      }

      // Clean up tracking for this event
      state.inputAttemptedDuringWindow.delete(i);
    }
  }

  const idx = getNextUnhitIndex();
  state.nextIdx = idx === -1 ? state.events.length - 1 : idx;
}

/**
 * Returns a verdict object for UI based on timing window matching
 */
function tryMatchPlayed(beatNow, playedFreq) {
  // Find nearest unhit note within timing window that's close enough in pitch
  const win = timingWindowBeats(state.bpm);
  let bestDb = Infinity;
  let idx = -1;
  let matchedChordTone = null;

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    if (ev.hit) continue; // allow retries until missed
    const db = Math.abs(beatNow - ev.beat);
    if (db <= win && db < bestDb) {

      if (ev.type === "chord") {
        // Check if played note matches any chord tone
        let chordMatch = null;
        for (const chordTone of ev.notes) {
          const { correctedMidi, centsOff } = octaveCorrect(playedFreq, chordTone.midi);
          const semitonesDiff = Math.abs(correctedMidi - chordTone.midi);

          if (semitonesDiff <= 1) { // Allow up to 1 semitone difference
            chordMatch = { chordTone, correctedMidi, centsOff };
            break;
          }
        }

        if (chordMatch) {
          bestDb = db;
          idx = i;
          matchedChordTone = chordMatch;
        }
      } else {
        // Single note matching (existing logic)
        const { correctedMidi, centsOff } = octaveCorrect(playedFreq, ev.midi);
        const semitonesDiff = Math.abs(correctedMidi - ev.midi);

        if (semitonesDiff <= 1) { // Allow up to 1 semitone difference
          bestDb = db;
          idx = i;
        }
      }
    }
  }

  if (idx === -1) return null;

  // Mark that input was attempted for this note (for skipped vs missed tracking)
  state.inputAttemptedDuringWindow.add(idx);

  const ev = state.events[idx];

  let correctedMidi, centsOff, expectedMidi;

  if (ev.type === "chord" && matchedChordTone) {
    // Chord matching
    correctedMidi = matchedChordTone.correctedMidi;
    centsOff = matchedChordTone.centsOff;
    expectedMidi = matchedChordTone.chordTone.midi;
  } else {
    // Single note matching
    const correction = octaveCorrect(playedFreq, ev.midi);
    correctedMidi = correction.correctedMidi;
    centsOff = correction.centsOff;
    expectedMidi = ev.midi;
  }

  const ok = Math.abs(centsOff) <= CENTS_TOLERANCE;
  const timingBeats = beatNow - ev.beat;

  if (ok) {
    ev.hit = true;
    ev.judged = true;
  }

  return {
    ok,
    expected: expectedMidi,
    detected: correctedMidi,
    centsOff,
    timingBeats,
    expectedBeat: ev.beat,
    isChord: ev.type === "chord",
    chordTone: matchedChordTone?.chordTone,
    chordSize: ev.type === "chord" ? ev.notes.length : 1
  };
}

/**
 * -------------------------
 * Metronome (click on beat)
 * -------------------------
 * Uses AudioContext oscillator for a short "tick".
 * Downbeat is higher frequency.
 */
function metroTick(isDownbeat) {
  if (!state.audioCtx) return;
  const ctx = state.audioCtx;

  // Duck detection briefly after we emit the tick (prevents mic hearing the click)
  state.ignoreUntil = Math.max(state.ignoreUntil, ctx.currentTime + 0.12);

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";
  osc.frequency.value = isDownbeat ? 1200 : 880;

  const t = ctx.currentTime;
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(0.20, t + 0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start(t);
  osc.stop(t + 0.07);
}


/**
 * -------------------------
 * Adaptive Calibration System
 * -------------------------
 */
function updateAdaptiveCalibration(analyser, rms, isPlaying) {
  const cal = state.adaptiveCalibration;
  if (!cal.enabled) return cal.adaptiveThreshold;

  const now = performance.now();

  // Get frequency domain data for energy analysis
  const bufferLength = analyser.frequencyBinCount;
  const dataArray = new Float32Array(bufferLength);
  analyser.getFloatFrequencyData(dataArray);

  // Calculate average energy across frequency spectrum
  let totalEnergy = 0;
  let validBins = 0;
  for (let i = 0; i < bufferLength; i++) {
    if (dataArray[i] > -100) { // Ignore extremely low values
      totalEnergy += dataArray[i];
      validBins++;
    }
  }
  const avgEnergy = validBins > 0 ? totalEnergy / validBins : -60;

  // Adaptive learning based on playing state
  if (isPlaying && rms > 0.001) {
    // Learning phase: user is playing
    cal.activeSamples++;

    // Update signal peak with exponential moving average
    if (avgEnergy > cal.signalPeak || cal.activeSamples < 10) {
      cal.signalPeak += cal.learningRate * (avgEnergy - cal.signalPeak);
    }

    // Reset silence counter
    cal.silentSamples = 0;

  } else if (rms < 0.001) {
    // Silence phase: detecting noise floor
    cal.silentSamples++;

    if (cal.silentSamples > 10) { // Only after sustained silence
      cal.noiseFloor += cal.learningRate * (avgEnergy - cal.noiseFloor);
    }
  }

  // Calculate confidence based on sample count and signal separation
  const totalSamples = cal.activeSamples + cal.silentSamples;
  const sampleConfidence = Math.min(1, totalSamples / cal.minSamples);
  const separationConfidence = Math.min(1, (cal.signalPeak - cal.noiseFloor) / 20); // 20dB = good separation
  cal.confidence = sampleConfidence * separationConfidence;

  // Calculate adaptive threshold (halfway between noise floor and signal peak, with safety margin)
  const rawThreshold = cal.noiseFloor + (cal.signalPeak - cal.noiseFloor) * 0.3;

  // Blend with manual threshold based on confidence
  const manualThreshold = parseFloat($("fftThreshold").value || -40);
  cal.adaptiveThreshold = (1 - cal.confidence) * manualThreshold + cal.confidence * rawThreshold;

  // Clamp to reasonable bounds
  cal.adaptiveThreshold = Math.max(-60, Math.min(-20, cal.adaptiveThreshold));

  // Update UI every 1000ms
  if (now - cal.lastUpdate > 1000) {
    updateAdaptiveCalibrationUI();
    cal.lastUpdate = now;
  }

  return cal.adaptiveThreshold;
}

function updateAdaptiveCalibrationUI() {
  const cal = state.adaptiveCalibration;
  if (!cal.enabled) return;

  // Update threshold slider if in auto mode
  if (cal.confidence > 0.3) {
    const roundedThreshold = Math.round(cal.adaptiveThreshold);
    if (Math.abs(parseFloat($("fftThreshold").value) - roundedThreshold) > 1) {
      $("fftThreshold").value = roundedThreshold;
      $("fftThresholdNum").value = roundedThreshold;
    }
  }

  // Enhanced status display
  const confidencePercent = Math.round(cal.confidence * 100);
  const separation = cal.signalPeak - cal.noiseFloor;

  let statusText = `Auto: ${cal.adaptiveThreshold.toFixed(1)}dB `;
  statusText += `(${confidencePercent}% confident, ${separation.toFixed(1)}dB range)`;

  // Color based on calibration quality
  if (cal.confidence > 0.7 && separation > 15) {
    $("fftStatus").style.color = "#1a7f37"; // Green: well calibrated
  } else if (cal.confidence > 0.3) {
    $("fftStatus").style.color = "#ff9900"; // Orange: learning
  } else {
    $("fftStatus").style.color = "#666"; // Gray: not enough data
  }

  // Only show auto status when not actively detecting
  if (!state.practicing || $("fftStatus").textContent.includes("Threshold:")) {
    $("fftStatus").textContent = statusText;
  }
}

function resetAdaptiveCalibration() {
  const cal = state.adaptiveCalibration;
  cal.noiseFloor = -60;
  cal.signalPeak = -20;
  cal.adaptiveThreshold = -40;
  cal.silentSamples = 0;
  cal.activeSamples = 0;
  cal.confidence = 0;
  cal.lastUpdate = 0;
  updateAdaptiveCalibrationUI();
}

/**
 * -------------------------
 * Hardware Calibration System (Open Strings)
 * -------------------------
 */

const CALIBRATION_STRINGS = [
  { name: "Low E (6th)", midi: 40, freq: 82.4 },
  { name: "A (5th)", midi: 45, freq: 110.0 },
  { name: "D (4th)", midi: 50, freq: 146.8 },
  { name: "G (3rd)", midi: 55, freq: 196.0 },
  { name: "B (2nd)", midi: 59, freq: 246.9 },
  { name: "High E (1st)", midi: 64, freq: 329.6 }
];

function startHardwareCalibration() {
  const cal = state.hardwareCalibration;
  cal.isCalibrating = true;
  cal.currentString = 0;
  cal.stringData = [];
  cal.quality = 0;

  // Show modal
  $("calibrationModal").style.display = "block";
  $("calibrationOverlay").style.display = "block";
  $("calibrationResults").style.display = "none";
  $("closeCalibration").disabled = true;

  // Start with noise floor measurement
  updateCalibrationUI();
  measureNoiseFloor();
}

function measureNoiseFloor() {
  $("calibrationInstruction").textContent = "üîá Measuring background noise...";
  $("calibrationDetails").textContent = "Stay quiet for 3 seconds";
  $("calibrationProgressBar").style.width = "8%";

  let samples = [];
  let sampleCount = 0;
  const maxSamples = 60; // ~3 seconds at 20fps

  const measureInterval = setInterval(() => {
    if (!state.analyser) {
      clearInterval(measureInterval);
      return;
    }

    // Get frequency domain data
    const bufferLength = state.analyser.frequencyBinCount;
    const dataArray = new Float32Array(bufferLength);
    state.analyser.getFloatFrequencyData(dataArray);

    // Calculate average energy
    let totalEnergy = 0;
    let validBins = 0;
    for (let i = 0; i < bufferLength; i++) {
      if (dataArray[i] > -100) {
        totalEnergy += dataArray[i];
        validBins++;
      }
    }
    const avgEnergy = validBins > 0 ? totalEnergy / validBins : -60;
    samples.push(avgEnergy);

    sampleCount++;
    const progress = 8 + (sampleCount / maxSamples) * 10; // 8-18%
    $("calibrationProgressBar").style.width = `${progress}%`;

    if (sampleCount >= maxSamples) {
      clearInterval(measureInterval);

      // Calculate noise floor (10th percentile for robustness)
      samples.sort((a, b) => a - b);
      state.hardwareCalibration.noiseFloor = samples[Math.floor(samples.length * 0.1)];

      // Start string measurements
      measureNextString();
    }
  }, 50); // 20fps
}

function measureNextString() {
  const cal = state.hardwareCalibration;

  if (cal.currentString >= CALIBRATION_STRINGS.length) {
    finishCalibration();
    return;
  }

  const stringInfo = CALIBRATION_STRINGS[cal.currentString];
  const progress = 18 + (cal.currentString / CALIBRATION_STRINGS.length) * 72; // 18-90%

  $("calibrationInstruction").textContent = `üé∏ Play ${stringInfo.name} string`;
  $("calibrationDetails").textContent = `Expected: ${stringInfo.freq ? stringInfo.freq.toFixed(1) : "--"}Hz (${midiToName(stringInfo.midi)}) - Strum clearly`;
  $("calibrationProgressBar").style.width = `${progress}%`;

  let samples = [];
  let validSamples = 0;
  const maxSamples = 100; // ~5 seconds at 20fps
  let bestSignal = -100;

  const measureInterval = setInterval(() => {
    if (!state.analyser) {
      clearInterval(measureInterval);
      return;
    }

    // Get time domain for YIN and frequency domain for FFT
    const timeBuf = new Float32Array(state.analyser.fftSize);
    state.analyser.getFloatTimeDomainData(timeBuf);

    const freqBuf = new Float32Array(state.analyser.frequencyBinCount);
    state.analyser.getFloatFrequencyData(freqBuf);

    // Use YIN to detect the played note
    const pitchResult = yinPitch(timeBuf, state.audioCtx.sampleRate);

    if (pitchResult.freq && pitchResult.conf > 0.5 && pitchResult.rms > 0.001) {
      const detectedMidi = freqToMidi(pitchResult.freq);
      const expectedMidi = stringInfo.midi;
      const semitonesDiff = Math.abs(detectedMidi - expectedMidi);

      // Check if it matches the expected string (within 1 semitone)
      if (semitonesDiff <= 1) {
        // Calculate signal strength in frequency domain
        const targetFreq = stringInfo.freq;
        const nyquist = state.audioCtx.sampleRate / 2;
        const freqPerBin = nyquist / freqBuf.length;
        const targetBin = Math.round(targetFreq / freqPerBin);

        let peakEnergy = -100;
        for (let i = Math.max(0, targetBin - 2); i <= Math.min(freqBuf.length - 1, targetBin + 2); i++) {
          peakEnergy = Math.max(peakEnergy, freqBuf[i]);
        }

        samples.push({
          energy: peakEnergy,
          freq: pitchResult.freq,
          conf: pitchResult.conf,
          rms: pitchResult.rms
        });

        bestSignal = Math.max(bestSignal, peakEnergy);
        validSamples++;

        // Visual feedback
        $("calibrationDetails").textContent = `‚úì Detected: ${pitchResult.freq ? pitchResult.freq.toFixed(1) : "--"}Hz (${validSamples} samples) - Keep playing!`;
      }
    }

    validSamples++;
    if (validSamples >= maxSamples) {
      clearInterval(measureInterval);

      // Store string data
      if (samples.length >= 5) { // Need at least 5 good samples
        const avgEnergy = samples.reduce((sum, s) => sum + s.energy, 0) / samples.length;
        const avgConf = samples.reduce((sum, s) => sum + s.conf, 0) / samples.length;

        cal.stringData.push({
          string: stringInfo.name,
          midi: stringInfo.midi,
          expectedFreq: stringInfo.freq,
          avgEnergy,
          avgConf,
          samples: samples.length,
          quality: Math.min(1, avgConf * (samples.length / 20)) // Quality based on confidence and sample count
        });

        $("calibrationDetails").textContent = `‚úì ${stringInfo.name} calibrated (${samples.length} samples, ${avgEnergy.toFixed(1)}dB)`;
      } else {
        // Failed to get good samples for this string
        cal.stringData.push({
          string: stringInfo.name,
          midi: stringInfo.midi,
          expectedFreq: stringInfo.freq,
          avgEnergy: cal.noiseFloor + 10, // Estimate
          avgConf: 0,
          samples: 0,
          quality: 0
        });

        $("calibrationDetails").textContent = `‚ö† ${stringInfo.name} - insufficient data, using defaults`;
      }

      cal.currentString++;
      setTimeout(measureNextString, 1000); // 1 second pause between strings
    }
  }, 50); // 20fps
}

function finishCalibration() {
  const cal = state.hardwareCalibration;

  // Calculate optimal threshold and quality
  const validStrings = cal.stringData.filter(s => s.samples >= 3);

  if (validStrings.length >= 3) {
    // Calculate average signal level
    cal.averageSignal = validStrings.reduce((sum, s) => sum + s.avgEnergy, 0) / validStrings.length;

    // Set threshold 30% above noise floor toward average signal
    const signalRange = cal.averageSignal - cal.noiseFloor;
    cal.optimalThreshold = cal.noiseFloor + (signalRange * 0.3);

    // Calculate quality score
    const avgQuality = validStrings.reduce((sum, s) => sum + s.quality, 0) / validStrings.length;
    const coverageQuality = validStrings.length / CALIBRATION_STRINGS.length;
    const separationQuality = Math.min(1, signalRange / 15); // 15dB = good separation

    cal.quality = (avgQuality + coverageQuality + separationQuality) / 3;
  } else {
    // Failed calibration - use defaults
    cal.optimalThreshold = -40;
    cal.quality = 0;
  }

  cal.isCalibrated = true;
  cal.isCalibrating = false;
  cal.timestamp = Date.now();

  // Update UI
  $("calibrationProgressBar").style.width = "100%";
  $("calibrationInstruction").textContent = cal.quality > 0.6 ? "‚úÖ Calibration Complete!" : "‚ö† Calibration Complete (Limited Data)";

  showCalibrationResults();
  updateCalibrationStatus();

  // Update FFT threshold
  updateFFTThresholdFromCalibration();
}

function showCalibrationResults() {
  const cal = state.hardwareCalibration;
  $("calibrationResults").style.display = "block";

  let summaryHTML = `<div style="margin-bottom:12px;">
    <strong>Quality Score:</strong> ${Math.round(cal.quality * 100)}%
    (${cal.quality > 0.8 ? 'Excellent' : cal.quality > 0.6 ? 'Good' : cal.quality > 0.4 ? 'Fair' : 'Poor'})
  </div>`;

  summaryHTML += `<div style="margin-bottom:12px;">
    <strong>Signal Range:</strong> ${(cal.averageSignal - cal.noiseFloor).toFixed(1)}dB
    (Noise: ${cal.noiseFloor.toFixed(1)}dB, Signal: ${cal.averageSignal.toFixed(1)}dB)
  </div>`;

  summaryHTML += `<div style="margin-bottom:12px;">
    <strong>Optimal Threshold:</strong> ${cal.optimalThreshold.toFixed(1)}dB
  </div>`;

  summaryHTML += `<div style="font-size:11px;">`;
  for (const stringData of cal.stringData) {
    const status = stringData.samples >= 3 ? '‚úì' : '‚ö†';
    summaryHTML += `${status} ${stringData.string}: ${stringData.samples} samples, ${stringData.avgEnergy.toFixed(1)}dB<br>`;
  }
  summaryHTML += `</div>`;

  $("calibrationSummary").innerHTML = summaryHTML;
  $("closeCalibration").disabled = false;
}

function updateCalibrationUI() {
  // This is called during calibration to update progress
}

function updateCalibrationStatus() {
  const cal = state.hardwareCalibration;
  const statusEl = $("calibrationStatus");

  if (cal.isCalibrated) {
    const qualityPercent = Math.round(cal.quality * 100);
    const timeAgo = Math.round((Date.now() - cal.timestamp) / (1000 * 60));

    statusEl.textContent = `Calibrated ${qualityPercent}% (${timeAgo}m ago)`;
    statusEl.style.color = cal.quality > 0.6 ? "#1a7f37" : cal.quality > 0.4 ? "#ff9900" : "#b42318";

    $("btnCalibrate").textContent = "üîÑ Re-calibrate";
    $("btnCalibrate").style.background = cal.quality > 0.6 ? "#1a7f37" : "#ff9900";
  } else {
    statusEl.textContent = "Not calibrated";
    statusEl.style.color = "#b42318";
    $("btnCalibrate").textContent = "üé∏ Calibrate Hardware";
    $("btnCalibrate").style.background = "#0066cc";
  }
}

function updateFFTThresholdFromCalibration() {
  const cal = state.hardwareCalibration;
  if (cal.isCalibrated && cal.quality > 0.3) {
    // Update the FFT threshold controls
    setFftThreshold(cal.optimalThreshold);

    // Disable adaptive calibration in favor of hardware calibration
    state.adaptiveCalibration.enabled = false;
    $("adaptiveCalibration").checked = false;
  }
}

function closeCalibrationModal() {
  $("calibrationModal").style.display = "none";
  $("calibrationOverlay").style.display = "none";
}

/**
 * -------------------------
 * App state
 * -------------------------
 */
const state = {
  audioCtx: null,
  analyser: null,
  micStream: null,
  rafId: null,

  // Hardware calibration state (open string sequence)
  hardwareCalibration: {
    isCalibrated: false,
    isCalibrating: false,
    currentString: 0, // 0-5 (E-A-D-G-B-E)
    stringData: [], // Measured data for each string
    noiseFloor: -60, // Background noise level
    averageSignal: -30, // Average string signal level
    optimalThreshold: -40, // Calculated optimal threshold
    quality: 0, // 0-1, calibration quality score
    timestamp: null // When calibration was completed
  },

  // Adaptive calibration state (deprecated - replaced by hardware calibration)
  adaptiveCalibration: {
    enabled: false, // Disabled by default, hardware calibration takes priority
    noiseFloor: -60,
    signalPeak: -20,
    adaptiveThreshold: -40,
    learningRate: 0.05,
    silentSamples: 0,
    activeSamples: 0,
    lastUpdate: 0,
    confidence: 0,
    minSamples: 100
  },

  practicing: false,

  bpm: DEFAULT_BPM,

  // time model:
  // beatNow = secondsToBeats(audioCtx.currentTime - startTime, bpm)
  startTime: 0,

  // metronome scheduler:
  lastMetroBeat: -1,
  nextMetroTime: 0,

  // detection stability:
  stableCount: 0,
  lastMidiRounded: null,
  lastTriggerAt: 0,

  // Track input attempts for skipped vs missed detection
  inputAttemptedDuringWindow: new Set(), // Set of event indices that had input attempts

  // song events:
  events: song.map(e => ({...e, hit:false, miss:false, skipped:false, judged:false, visualNote:null })),
  nextIdx: 0,

  // visual notes on fretboard
  visualNotes: new Map(),  // noteId -> visual note element
  nextNoteId: 0,

  // score tracking
  successCount: 0,
  failCount: 0,
  skippedCount: 0,

  ignoreUntil: 0,          // audioCtx time until which we ignore detection (ducking)
  lastRms: 0,              // optional: simple onset gating baseline
  // auto-stop tracking for exercise completion
  exerciseCompleted: false,
  exerciseEndBeat: null,
  autoStopScheduled: false,
  // metronome-only time limit (10 minutes)
  metronomeStartTime: null,
  metronomeTimeLimit: 10 * 60, // 10 minutes in seconds

  // Enhanced debug logging
  debugLog: [],

  // Practice history tracking
  practiceHistory: []
};

function resetPractice() {
  state.practicing = false;
  state.startTime = 0;
  state.lastMetroBeat = -1;
  state.nextMetroTime = 0;

  state.stableCount = 0;
  state.lastMidiRounded = null;
  state.lastTriggerAt = 0;

  state.events = song.map(e => ({...e, hit:false, miss:false, skipped:false, judged:false, visualNote:null }));
  state.nextIdx = 0;

  // Clear input tracking
  state.inputAttemptedDuringWindow.clear();

  // Reset auto-stop tracking
  state.exerciseCompleted = false;
  state.exerciseEndBeat = null;
  state.autoStopScheduled = false;
  state.metronomeStartTime = null;

  // Clear visual notes
  clearVisualNotes();

  // Reset score counters
  state.successCount = 0;
  state.failCount = 0;
  state.skippedCount = 0;
  updateScoreDisplay();

  $("now").textContent = "‚Äî";
  $("lastNote").textContent = "‚Äî";
  $("lastNoteMeta").textContent = "‚Äî";
  $("status").textContent = "ready";
  renderNotes();
}

function currentBeat(nowAudioTime) {
  const elapsed = nowAudioTime - state.startTime;
  return secondsToBeats(elapsed, state.bpm);
}

/**
 * -------------------------
 * Main loop
 * -------------------------
 */
function loop() {
  if (!state.practicing) return;

  console.log("üöÄüöÄüöÄ MAIN LOOP EXECUTING - VERSION CHECK üöÄüöÄüöÄ");

  const now = state.audioCtx.currentTime;
  const beatNow = currentBeat(now);

  // Always update visual elements first (prevents animation stuttering)
  // Update visual notes animation
  updateVisualNotes(beatNow);

  // Skip audio processing briefly after metronome tick (prevents self-triggering)
  // but continue with visual updates
  const skipAudioProcessing = now < state.ignoreUntil;

  // Count-in handling (beatNow < 0 means we're counting in)
  if (beatNow < 0) {
    $("now").textContent = `count-in‚Ä¶ beat=${beatNow.toFixed(2)} @ ${state.bpm} BPM`;
  } else {
    $("now").textContent = `beat=${beatNow.toFixed(3)} @ ${state.bpm} BPM`;
  }

  // Metronome tick (including count-in if enabled) with precise timing
  if ($("metroOn").checked) {
    if (now >= state.nextMetroTime && state.nextMetroTime > 0) {
      const currentBeatInt = Math.floor(beatNow);

      // Determine downbeat within bars (handles negative beats too)
      const barPos = ((currentBeatInt % BEATS_PER_BAR) + BEATS_PER_BAR) % BEATS_PER_BAR;
      const isDownbeat = (barPos === 0);
      metroTick(isDownbeat);

      // Schedule next tick precisely
      const beatDuration = beatsToSeconds(1, state.bpm);
      state.nextMetroTime += beatDuration;

      // Prevent accumulating drift by resetting if we get too far behind
      if (state.nextMetroTime < now - beatDuration) {
        state.nextMetroTime = now + beatDuration;
      }
    }
  }

  // Audio processing (skip during metronome ducking period)
  let freq = null, conf = 0, rms = 0, onset = false;
  let debugReason = "";
  let detectionMethod = "none";
  let chordDetectionResult = null;

  console.log("üéõÔ∏è AUDIO PROCESSING DEBUG: skipAudioProcessing =", skipAudioProcessing, "now =", now.toFixed(3), "ignoreUntil =", state.ignoreUntil.toFixed(3));

  if (!skipAudioProcessing) {
    try {
      // Read mic samples
      const buf = new Float32Array(state.analyser.fftSize);
      state.analyser.getFloatTimeDomainData(buf);

      // Get current expected event to decide detection strategy
      const expectedEvent = getCurrentExpectedEvent(beatNow);

      console.log("üéõÔ∏è AUDIO PROCESSING DEBUG: About to call hybrid detection");

      // Use hybrid detection system
      const detection = hybridDetection(state.analyser, buf, state.audioCtx.sampleRate, expectedEvent);
      detectionMethod = detection.method;

      if (detection.method === 'yin' || detection.method.includes('yin')) {
        // Single note detection via YIN (including all fallback modes)
        const pitchResult = detection.result;
        freq = pitchResult.freq;
        conf = pitchResult.conf;
        rms = pitchResult.rms;
      } else if (detection.method === 'fft') {
        // Chord detection via FFT
        chordDetectionResult = detection.result;
        console.log("üéµ MAIN DEBUG: FFT result received:", chordDetectionResult);

        // Calculate real RMS from time domain data for onset detection
        let rmsSum = 0;
        for (let i = 0; i < buf.length; i++) {
          rmsSum += buf[i] * buf[i];
        }
        rms = Math.sqrt(rmsSum / buf.length);

        conf = chordDetectionResult ? chordDetectionResult.confidence : 0;
        freq = null; // No single frequency for chords
      } else {
        // Ultimate fallback - use YIN as default
        const pitchResult = yinPitch(buf, state.audioCtx.sampleRate);
        freq = pitchResult.freq;
        conf = pitchResult.conf;
        rms = pitchResult.rms;
        detectionMethod = 'yin-ultimate-fallback';
      }

      // crude onset: require a jump in level vs previous frame (helps ignore steady speech/background)
      // Simplified for guitar: just need RMS above minimum OR a relative jump
      onset = rms > 0.004 || rms > state.lastRms * 1.2;
      state.lastRms = 0.9 * state.lastRms + 0.1 * rms; // smooth baseline

      // Update adaptive calibration based on current activity
      const isCurrentlyPlaying = onset && rms > 0.001;
      updateAdaptiveCalibration(state.analyser, rms, isCurrentlyPlaying);
    } catch (error) {
      // Error in detection - log and continue with defaults
      console.error("Detection error:", error);
      detectionMethod = "error";
      rms = 0;
      conf = 0;
      onset = false;
    }
  }

  // UI: input level / debug
  $("level").value = Math.min(1, rms * 20);

  // Enhanced debug display for hybrid detection
  let debugText = `rms=${rms.toFixed(4)} conf=${conf.toFixed(2)} method=${detectionMethod}`;
  if (detectionMethod === 'yin' || detectionMethod.includes('yin')) {
    debugText += ` freq=${freq ? freq.toFixed(1) : "‚Äî"}`;
    if (detectionMethod.includes('fallback')) {
      debugText += ` (FALLBACK)`;
    }
    if (detectionMethod.includes('bypass')) {
      debugText += ` (BYPASS)`;
    }
  } else if (detectionMethod === 'fft' && chordDetectionResult) {
    debugText += ` chord=${chordDetectionResult.detectedCount}/${chordDetectionResult.requiredCount}`;
    if (chordDetectionResult.isStrong) {
      debugText += ` STRONG`;
    }
    if (chordDetectionResult.detectedNotes && chordDetectionResult.detectedNotes.length > 0) {
      const maxEnergy = Math.max(...chordDetectionResult.detectedNotes.map(n => Math.max(n.fundamentalEnergy, n.harmonicEnergy)));
      debugText += ` peak=${maxEnergy.toFixed(1)}dB`;
    }
  } else {
    debugText += ` freq=${freq ? freq.toFixed(1) : "‚Äî"}`;
  }

  $("levelText").textContent = debugText;

  // Update FFT status display with real-time feedback
  if (detectionMethod === 'fft' && chordDetectionResult) {
    const threshold = parseFloat($("fftThreshold").value || -40);
    let statusText = `Detecting: ${chordDetectionResult.detectedCount}/${chordDetectionResult.requiredCount} `;

    if (chordDetectionResult.detectedNotes.length > 0) {
      const maxEnergy = Math.max(...chordDetectionResult.detectedNotes.map(n => Math.max(n.fundamentalEnergy, n.harmonicEnergy)));
      const margin = maxEnergy - threshold;
      statusText += `(${maxEnergy.toFixed(1)}dB, +${margin.toFixed(1)}dB margin)`;

      // Color code based on detection quality
      if (chordDetectionResult.success) {
        $("fftStatus").style.color = "#1a7f37"; // Green for success
      } else if (chordDetectionResult.confidence > 0.5) {
        $("fftStatus").style.color = "#ff9900"; // Orange for partial detection
      } else {
        $("fftStatus").style.color = "#b42318"; // Red for poor detection
      }
    } else {
      statusText += "(no signal)";
      $("fftStatus").style.color = "#666"; // Gray for no signal
    }

    $("fftStatus").textContent = statusText;
  } else if (detectionMethod === 'yin') {
    $("fftStatus").style.color = "#666";
    $("fftStatus").textContent = `YIN mode (single notes)`;
  } else {
    $("fftStatus").style.color = "#666";
    $("fftStatus").textContent = `Threshold: ${parseFloat($("fftThreshold").value || -40)}dB`;
  }

  // Visual notes already updated above (to prevent stuttering)

  // If we're still in count-in, do not judge notes (but still show detected pitch)
  if (beatNow < 0) {
    state.rafId = requestAnimationFrame(loop);
    return;
  }

  // Pitch processing and note matching (skip during metronome ducking)
  let midiFloat = null;
  let midiRounded = null;
  let shouldProcessDetection = false;

  if (!skipAudioProcessing) {
    // Trigger gate - make cooldown tempo-aware
    const beatDurationSec = 60 / state.bpm;
    const adaptiveCooldown = Math.min(COOLDOWN_SEC, beatDurationSec * 0.3); // Max 30% of beat duration
    const canTrigger = (now - state.lastTriggerAt) > adaptiveCooldown;

    // Reduced cooldown for chords to allow quick transitions
    const chordCooldown = Math.min(adaptiveCooldown * 0.5, 0.1); // Half cooldown or max 100ms
    const canTriggerChord = (now - state.lastTriggerAt) > chordCooldown;

    if (detectionMethod === 'yin' && freq) {
      // YIN single note detection logic
      midiFloat = freqToMidi(freq);
      midiRounded = Math.round(midiFloat);

      // Stability gate for YIN
      if (midiRounded !== null) {
        if (state.lastMidiRounded === midiRounded) state.stableCount++;
        else { state.lastMidiRounded = midiRounded; state.stableCount = 1; }
      } else {
        state.lastMidiRounded = null;
        state.stableCount = 0;
      }

      // Debug: Check why YIN detection might fail
      if (freq !== null && rms > MIN_RMS) {
        const reasons = [];
        if (conf < 0.65) reasons.push(`conf=${conf.toFixed(2)}<0.65`);
        if (!onset) {
          const minThreshold = 0.004;
          const relativeThreshold = state.lastRms * 1.2;
          reasons.push(`no onset (rms=${rms.toFixed(4)} ‚â§ ${minThreshold} AND ‚â§ ${relativeThreshold.toFixed(4)})`);
        }
        if (midiFloat === null) reasons.push("no MIDI");
        if (state.stableCount < STABLE_FRAMES) reasons.push(`unstable=${state.stableCount}/${STABLE_FRAMES}`);
        if (!canTrigger) reasons.push(`cooldown (${adaptiveCooldown.toFixed(2)}s)`);

        if (reasons.length > 0) {
          debugReason = `üîç YIN DETECTED ${freq ? freq.toFixed(1) : "--"}Hz (${midiToName(Math.round(freqToMidi(freq)))}) but BLOCKED: ${reasons.join(", ")}`;
        }
      } else if (rms > 0.001) {
        debugReason = `üîá YIN SIGNAL TOO WEAK: rms=${rms.toFixed(4)} (need >${MIN_RMS}) or no frequency detected`;
      }

      shouldProcessDetection = !state.exerciseCompleted && conf >= 0.65 && onset && midiFloat !== null && state.stableCount >= STABLE_FRAMES && canTrigger;

    } else if (detectionMethod === 'fft' && chordDetectionResult) {
      // FFT chord detection logic
      state.stableCount = STABLE_FRAMES; // Skip stability check for chords
      state.lastMidiRounded = null;

      // Debug: Check why FFT detection might fail
      if (chordDetectionResult.detectedCount > 0) {
        const reasons = [];
        if (conf < 0.2) reasons.push(`conf=${conf.toFixed(2)}<0.2`); // Lower threshold for chords
        // Note: No onset requirement for chords - they can be sustained
        if (!chordDetectionResult.success) {
          reasons.push(`partial chord (${chordDetectionResult.detectedCount}/${chordDetectionResult.requiredCount}, need ${chordDetectionResult.majorityThreshold}+)`);
        }
        if (!canTriggerChord) reasons.push(`cooldown (${chordCooldown.toFixed(2)}s)`);

        if (reasons.length > 0) {
          debugReason = `üîç FFT DETECTED ${chordDetectionResult.detectedCount}/${chordDetectionResult.requiredCount} chord tones but BLOCKED: ${reasons.join(", ")}`;
        }
      } else {
        console.log("üîá FFT DEBUG: No chord tones detected, chordDetectionResult:", chordDetectionResult);
        debugReason = `üîá FFT NO CHORD DETECTED: conf=${conf.toFixed(2)}`;
      }

      // Chord detection: Always process if we have a result, success or failure
      // This prevents animation from stopping when chords aren't perfectly detected
      shouldProcessDetection = !state.exerciseCompleted && chordDetectionResult && canTriggerChord;
    }

    if (shouldProcessDetection) {
      state.lastTriggerAt = now;

      let verdict = null;

      if (detectionMethod === 'yin') {
        // Match single note using existing logic
        verdict = tryMatchPlayed(beatNow, freq);

        // UI: show detected note
        $("lastNote").textContent = midiToName(midiRounded);
        $("lastNote").classList.add("flash");

      } else if (detectionMethod === 'fft') {
        // FFT chord detection with intelligent feedback
        const expectedEvent = getCurrentExpectedEvent(beatNow);

        if (expectedEvent && expectedEvent.type === "chord") {
          const detectedCount = chordDetectionResult.detectedCount || 0;
          const requiredCount = expectedEvent.notes.length;
          const success = chordDetectionResult.success || false;

          // Provide feedback based on detection quality
          if (success && detectedCount >= 1) {
            // Successful chord detection
            verdict = {
              ok: true,
              expected: expectedEvent.notes[0].midi,
              detected: expectedEvent.notes[0].midi,
              centsOff: 0,
              timingBeats: beatNow - expectedEvent.beat,
              expectedBeat: expectedEvent.beat,
              isChord: true,
              chordTone: null,
              chordSize: expectedEvent.notes.length
            };

            expectedEvent.hit = true;
            expectedEvent.judged = true;

            // Show detailed chord feedback
            const detectedNames = chordDetectionResult.detectedNotes.map(note => midiToName(note.midi)).join('+');
            $("lastNote").textContent = `${detectedNames} (${detectedCount}/${requiredCount})`;

          } else if (detectedCount > 0) {
            // Partial chord detection - still give partial credit
            verdict = {
              ok: true, // Give credit for partial detection
              expected: expectedEvent.notes[0].midi,
              detected: expectedEvent.notes[0].midi,
              centsOff: 0,
              timingBeats: beatNow - expectedEvent.beat,
              expectedBeat: expectedEvent.beat,
              isChord: true,
              chordTone: "partial",
              chordSize: expectedEvent.notes.length
            };

            expectedEvent.hit = true;
            expectedEvent.judged = true;

            $("lastNote").textContent = `Partial (${detectedCount}/${requiredCount})`;

          } else {
            // No chord detected - mark as miss but continue animation
            verdict = {
              ok: false,
              expected: expectedEvent.notes[0].midi,
              detected: expectedEvent.notes[0].midi,
              centsOff: 999, // Large value to indicate miss
              timingBeats: beatNow - expectedEvent.beat,
              expectedBeat: expectedEvent.beat,
              isChord: true,
              chordTone: null,
              chordSize: expectedEvent.notes.length
            };

            expectedEvent.miss = true;
            expectedEvent.judged = true;

            $("lastNote").textContent = `Chord Miss (0/${requiredCount})`;
          }

          $("lastNote").classList.add("flash");
        }
      }

      if (verdict) {
        const detectedName = midiToName(Math.round(verdict.detected));
        const expectedName = midiToName(verdict.expected);

        $("lastNoteMeta").textContent =
          `expected=${expectedName} detected‚âà${detectedName} ` +
          `cents=${verdict.centsOff.toFixed(1)} ` +
          `Œîbeat=${verdict.timingBeats.toFixed(2)} (win‚âà${timingWindowBeats(state.bpm).toFixed(2)})`;

        $("lastNote").style.outlineColor = verdict.ok ? "#1a7f37" : "#b42318";
        $("status").textContent = verdict.ok ? "‚úì correct" : "‚úó wrong";

        // Enhanced debug logging
        const rawMidiDetected = freqToMidi(freq);
        const rawNoteName = midiToName(Math.round(rawMidiDetected));

        let debugInfo;
        if (verdict.isChord) {
          const chordToneInfo = verdict.chordTone ?
            `string ${verdict.chordTone.string || "?"} fret ${verdict.chordTone.fret || "?"}` :
            "unknown position";

          debugInfo = [
            `üéµ CHORD ${verdict.ok ? "‚úì HIT" : "‚úó MISS"}`,
            `Matched: ${expectedName} (${chordToneInfo}) from ${verdict.chordSize}-note chord`,
            `Raw: ${rawNoteName} (${freq ? freq.toFixed(1) + "Hz" : "chord"}) ‚Üí Corrected: ${detectedName} (MIDI ${Math.round(verdict.detected)})`,
            `Conf: ${conf.toFixed(2)}`,
            `Timing: beat ${beatNow.toFixed(2)}, expected ${verdict.expectedBeat.toFixed(2)} (Œî${verdict.timingBeats.toFixed(2)})`,
            `Tolerance: ¬±${(timingWindowBeats(state.bpm).toFixed(2))} beats, ¬±${CENTS_TOLERANCE} cents`,
            `Cents Off: ${verdict.centsOff.toFixed(1)} (${Math.abs(verdict.centsOff) <= CENTS_TOLERANCE ? "within tolerance" : "outside tolerance"})`
          ].join(" | ");
        } else {
          debugInfo = [
            `üéµ SINGLE NOTE: ${verdict.ok ? "‚úì HIT" : "‚úó MISS"}`,
            `Expected: ${expectedName} (MIDI ${verdict.expected})`,
            `Raw: ${rawNoteName} (${freq ? freq.toFixed(1) + "Hz" : "chord"}) ‚Üí Corrected: ${detectedName} (MIDI ${Math.round(verdict.detected)})`,
            `Conf: ${conf.toFixed(2)}`,
            `Timing: beat ${beatNow.toFixed(2)}, expected ${verdict.expectedBeat.toFixed(2)} (Œî${verdict.timingBeats.toFixed(2)})`,
            `Tolerance: ¬±${(timingWindowBeats(state.bpm).toFixed(2))} beats, ¬±${CENTS_TOLERANCE} cents`,
            `Cents Off: ${verdict.centsOff.toFixed(1)} (${Math.abs(verdict.centsOff) <= CENTS_TOLERANCE ? "within tolerance" : "outside tolerance"})`
          ].join(" | ");
        }

        addDebugEntry(debugInfo);

        // Update score counters
        if (verdict.ok) {
          state.successCount++;
        } else {
          state.failCount++;
        }
        updateScoreDisplay();

        // Show immediate feedback
        showFullScreenFeedback(verdict.ok);
        showHitZoneFeedback(verdict.ok);
      } else {
        $("lastNoteMeta").textContent = `no note within timing window`;
        $("lastNote").style.outlineColor = "#999";
        $("status").textContent = "no match";

        // Log cases where no note was matched
        addDebugEntry(`üîç NO MATCH: Detected ${midiToName(midiRounded)} (${freq ? freq.toFixed(1) : "--"}Hz, conf ${conf.toFixed(2)}) at beat ${beatNow.toFixed(2)} but no expected note within timing window`);
      }

      setTimeout(() => $("lastNote").classList.remove("flash"), 200);
    } else if (debugReason && !state.exerciseCompleted) {
      // Log why detection failed (but don't spam - only during timing windows and before exercise completion)
      const hasActiveNote = state.events.some(ev => !ev.judged && Math.abs(beatNow - ev.beat) <= timingWindowBeats(state.bpm));
      if (hasActiveNote) {
        addDebugEntry(debugReason);
      }
    }

    // Update progression
    judgeMisses(beatNow);
    renderNotes();
  } else {
    // Audio processing skipped during metronome ducking, but still update misses
    judgeMisses(beatNow);
    renderNotes();
  }

  // Check if exercise is completed and schedule auto-stop (only for exercises with notes)
  if (!state.exerciseCompleted && state.events.length > 0) {
    const allNotesJudged = state.events.every(ev => ev.judged);
    if (allNotesJudged) {
      state.exerciseCompleted = true;
      // Find the last note's beat to calculate when to stop
      const lastNoteBeat = Math.max(...state.events.map(ev => ev.beat));
      state.exerciseEndBeat = lastNoteBeat + 4; // Stop 4 beats after last note
      $("status").textContent = "exercise complete, stopping in 4 beats...";

      // Log exercise completion and stop feedback spam
      addDebugEntry("üéâ EXERCISE COMPLETE: All notes judged. Stopping detection feedback to prevent sustained string spam.");
    }
  }

  // Auto-stop after exercise completion + 4 beats
  if (state.exerciseCompleted && !state.autoStopScheduled && beatNow >= state.exerciseEndBeat) {
    state.autoStopScheduled = true;
    $("btnStop").click(); // Trigger the stop button
    return; // Exit the loop
  }

  // 10-minute time limit for metronome-only mode (when no notes)
  if (state.events.length === 0 && state.metronomeStartTime) {
    const elapsedTime = now - state.metronomeStartTime;
    if (elapsedTime >= state.metronomeTimeLimit) {
      $("status").textContent = "10-minute metronome session completed";
      $("btnStop").click(); // Trigger the stop button
      return; // Exit the loop
    } else {
      // Show remaining time for metronome-only mode
      const remainingMinutes = Math.ceil((state.metronomeTimeLimit - elapsedTime) / 60);
      if (remainingMinutes <= 1 || Math.floor(elapsedTime) % 60 === 0) {
        $("status").textContent = `metronome (${remainingMinutes} min remaining)`;
      }
    }
  }

  state.rafId = requestAnimationFrame(loop);
}

/**
 * -------------------------
 * Controls
 * -------------------------
 */
function setBpm(bpm) {
  bpm = Math.max(40, Math.min(200, Number(bpm)));
  state.bpm = bpm;
  $("bpm").value = bpm;
  $("bpmNum").value = bpm;
}

$("bpm").addEventListener("input", (e) => setBpm(e.target.value));
$("bpmNum").addEventListener("change", (e) => setBpm(e.target.value));

// FFT calibration event handlers
function setFftThreshold(threshold) {
  threshold = Math.max(-60, Math.min(-20, Number(threshold)));
  $("fftThreshold").value = threshold;
  $("fftThresholdNum").value = threshold;
  $("fftStatus").textContent = `Threshold: ${threshold}dB (${threshold <= -50 ? 'Very Sensitive' : threshold <= -40 ? 'Normal' : threshold <= -30 ? 'Less Sensitive' : 'Strict'})`;
}

$("fftThreshold").addEventListener("input", (e) => setFftThreshold(e.target.value));
$("fftThresholdNum").addEventListener("change", (e) => setFftThreshold(e.target.value));

// Adaptive calibration controls
$("adaptiveCalibration").addEventListener("change", (e) => {
  state.adaptiveCalibration.enabled = e.target.checked;
  if (e.target.checked) {
    updateAdaptiveCalibrationUI();
  } else {
    $("fftStatus").style.color = "#666";
    $("fftStatus").textContent = `Manual mode: ${$("fftThreshold").value}dB`;
  }
});

$("resetCalibration").addEventListener("click", () => {
  resetAdaptiveCalibration();
});

// Hardware calibration event handlers
$("btnCalibrate").addEventListener("click", () => {
  if (!state.audioCtx || !state.analyser) {
    alert("Please enable microphone access first!");
    return;
  }
  startHardwareCalibration();
});

$("startCalibration").addEventListener("click", () => {
  // The calibration starts automatically when startHardwareCalibration is called
});

$("skipCalibration").addEventListener("click", () => {
  state.hardwareCalibration.isCalibrated = false;
  updateCalibrationStatus();
  closeCalibrationModal();
});

$("closeCalibration").addEventListener("click", () => {
  closeCalibrationModal();
});

// Close modal when clicking overlay
$("calibrationOverlay").addEventListener("click", () => {
  if (!state.hardwareCalibration.isCalibrating) {
    closeCalibrationModal();
  }
});

$("exercise").addEventListener("change", (e) => {
  const selectedFileName = e.target.value;
  const exercise = availableExercises.find(ex => (ex.fileName || "default") === selectedFileName);
  if (exercise) {
    loadExercise(exercise);
  }
});

$("btnMic").addEventListener("click", async () => {
  try {
    if (state.audioCtx || state.micStream) {
      console.log("Microphone already initialized");
      return;
    }

    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Request mic
    state.micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
      }
    });

    const src = state.audioCtx.createMediaStreamSource(state.micStream);

    // Bigger window helps low notes (E2)
    state.analyser = state.audioCtx.createAnalyser();
    state.analyser.fftSize = 8192;

    src.connect(state.analyser);

    $("micStatus").textContent = "Enabled ‚úì (listening)";
    $("status").textContent = "mic ready";
    $("btnStart").disabled = false;
    $("btnMic").textContent = "Mic Enabled ‚úì";
    $("btnMic").disabled = true;
  } catch (e) {
    let errorMessage = "Unknown error";
    let statusMessage = "mic error";

    if (e.name === "NotAllowedError") {
      errorMessage = "Microphone permission denied. Please allow microphone access and try again.";
      statusMessage = "permission denied";
    } else if (e.name === "NotFoundError") {
      errorMessage = "No microphone found. Please connect a microphone and try again.";
      statusMessage = "no microphone";
    } else if (e.name === "NotReadableError") {
      errorMessage = "Microphone in use by another application. Please close other apps and try again.";
      statusMessage = "mic busy";
    } else if (e.name === "OverconstrainedError") {
      errorMessage = "Microphone doesn't support required settings. Trying with default settings...";
      statusMessage = "retrying...";
      // Try again with less strict constraints
      try {
        state.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const src = state.audioCtx.createMediaStreamSource(state.micStream);
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = 8192;
        src.connect(state.analyser);

        $("micStatus").textContent = "Enabled ‚úì (basic settings)";
        $("status").textContent = "mic ready";
        $("btnStart").disabled = false;
        $("btnMic").textContent = "Mic Enabled ‚úì";
        $("btnMic").disabled = true;
        return;
      } catch (retryError) {
        errorMessage = `Microphone failed: ${retryError?.message || retryError}`;
        statusMessage = "mic failed";
      }
    } else {
      errorMessage = `Microphone error: ${e?.message || e}`;
    }

    $("micStatus").textContent = errorMessage;
    $("status").textContent = statusMessage;
    console.error("Microphone initialization failed:", e);

    // Reset state on error
    state.audioCtx = null;
    state.micStream = null;
    state.analyser = null;
  }
});

$("btnStart").addEventListener("click", async () => {
  if (!state.audioCtx) return;

  // Ensure AudioContext is running (some browsers need a user gesture)
  if (state.audioCtx.state === "suspended") {
    await state.audioCtx.resume();
  }

  resetPractice();

  state.practicing = true;

  // Set metronome start time for time limit tracking
  state.metronomeStartTime = state.audioCtx.currentTime;

  const useCountIn = $("countInOn").checked;
  const countInBeats = useCountIn ? BEATS_PER_BAR : 0;

  // Set start time in the future so beatNow starts negative (count-in)
  state.startTime = state.audioCtx.currentTime + beatsToSeconds(countInBeats, state.bpm);

  // Schedule first metronome tick precisely
  const beatDuration = beatsToSeconds(1, state.bpm);
  state.nextMetroTime = state.audioCtx.currentTime + beatDuration;

  $("btnStop").disabled = false;
  $("btnStart").disabled = true;
  $("status").textContent = useCountIn ? "count-in‚Ä¶" : "running";

  state.rafId = requestAnimationFrame(loop);

  // Log exercise start with expected notes sequence
  const exerciseNotes = state.events.map((ev, i) => {
    if (ev.type === "chord") {
      const chordTones = ev.notes.map(note => midiToName(note.midi)).join("+");
      return `${i + 1}: [${chordTones}] chord (beat ${ev.beat.toFixed(1)})`;
    } else {
      return `${i + 1}: ${midiToName(ev.midi)} (beat ${ev.beat.toFixed(1)})`;
    }
  }).join(", ");
  addDebugEntry(`üéº EXERCISE START: ${exerciseNotes}`);
});

$("btnStop").addEventListener("click", () => {
  // Save practice history before resetting stats (only if there was actual practice)
  const hadPractice = state.successCount > 0 || state.failCount > 0 || state.skippedCount > 0;
  console.log(`Stop pressed - practicing: ${state.practicing}, hadPractice: ${hadPractice}, stats: ${state.successCount}‚úì ${state.failCount}‚úó ${state.skippedCount}‚äù`);

  if (state.practicing && hadPractice) {
    addPracticeHistoryEntry();
    addDebugEntry(`üíæ SAVED PRACTICE: ${state.successCount}‚úì ${state.failCount}‚úó ${state.skippedCount}‚äù`);
  } else {
    addDebugEntry(`‚ùå NO SAVE: practicing=${state.practicing}, stats=${state.successCount}‚úì ${state.failCount}‚úó ${state.skippedCount}‚äù`);
  }

  state.practicing = false;

  // Cancel animation frame
  if (state.rafId) {
    cancelAnimationFrame(state.rafId);
    state.rafId = null;
  }

  // Reset practice state
  resetPractice();

  // Clean up visual notes
  clearVisualNotes();

  // Clean up audio resources (but keep mic enabled for quick restart)
  if (state.audioCtx && state.audioCtx.state !== "closed") {
    // Don't close the AudioContext to avoid reinitialization overhead
    // Just stop any scheduled audio
    state.ignoreUntil = 0;
    state.nextMetroTime = 0;
  }

  // Update UI
  $("btnStop").disabled = true;
  $("btnStart").disabled = false;
  $("status").textContent = "stopped";

  // Clear detection displays
  $("lastNote").textContent = "‚Äî";
  $("lastNoteMeta").textContent = "‚Äî";
  $("now").textContent = "‚Äî";
  if ($("lastNote").classList.contains("flash")) {
    $("lastNote").classList.remove("flash");
  }
});

// Initial render
setBpm(DEFAULT_BPM);
setFftThreshold(-40); // Initialize FFT threshold
updateCalibrationStatus(); // Initialize calibration status
renderNotes();
updateScoreDisplay();
$("status").textContent = "ready";

// Calculate proper travel distance based on fretboard width
calculateTravelDistance();

// Load available exercises
loadAvailableExercises();

// Debug button event listeners
$("clearDebug").addEventListener("click", clearDebugLog);
$("copyDebug").addEventListener("click", copyDebugToClipboard);

// Practice history button event listener
$("clearHistory").addEventListener("click", clearPracticeHistory);

// Recalculate on window resize
window.addEventListener('resize', () => {
  calculateTravelDistance();
});

// MusicXML Upload functionality
function setupMusicXMLUpload() {
  const uploadSection = $("uploadSection");
  const fileInput = $("musicxmlFile");
  const uploadStatus = $("uploadStatus");

  // Handle file input change
  fileInput.addEventListener("change", handleFileUpload);

  // Handle drag and drop
  uploadSection.addEventListener("dragover", (e) => {
    e.preventDefault();
    uploadSection.classList.add("dragover");
  });

  uploadSection.addEventListener("dragleave", (e) => {
    e.preventDefault();
    uploadSection.classList.remove("dragover");
  });

  uploadSection.addEventListener("drop", (e) => {
    e.preventDefault();
    uploadSection.classList.remove("dragover");

    const files = e.dataTransfer.files;
    if (files.length > 0) {
      handleFile(files[0]);
    }
  });

  function handleFileUpload(e) {
    const file = e.target.files[0];
    if (file) {
      handleFile(file);
    }
  }

  function handleFile(file) {
    // Validate file type
    const validExtensions = ['.mxl', '.xml', '.musicxml'];
    const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));

    if (!validExtensions.includes(fileExtension)) {
      showUploadStatus("Please select a MusicXML file (.mxl, .xml, or .musicxml)", "error");
      return;
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      showUploadStatus("File is too large. Please select a file smaller than 5MB.", "error");
      return;
    }

    showUploadStatus("Reading file...", "");

    // Check if it's a compressed .mxl file
    if (fileExtension === '.mxl') {
      // Read as binary for ZIP extraction
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          extractMXLFile(e.target.result, file.name);
        } catch (error) {
          console.error("Error reading MXL file:", error);
          showUploadStatus("Error reading MXL file. Please try again.", "error");
        }
      };

      reader.onerror = function() {
        showUploadStatus("Error reading MXL file. Please try again.", "error");
      };

      reader.readAsArrayBuffer(file);
    } else {
      // Read as text for XML files
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const xmlContent = e.target.result;
          processMusicXMLFile(xmlContent, file.name);
        } catch (error) {
          console.error("Error reading file:", error);
          showUploadStatus("Error reading file. Please try again.", "error");
        }
      };

      reader.onerror = function() {
        showUploadStatus("Error reading file. Please try again.", "error");
      };

      reader.readAsText(file);
    }
  }

  function extractMXLFile(arrayBuffer, fileName) {
    try {
      showUploadStatus("Extracting MXL file...", "");

      // Use JSZip to properly extract the MXL file
      JSZip.loadAsync(arrayBuffer).then(function(zip) {
        // Look for score.xml in the ZIP
        const scoreFile = zip.file("score.xml");

        if (!scoreFile) {
          showUploadStatus("Could not find score.xml in MXL file.", "error");
          return;
        }

        // Extract the score.xml content
        scoreFile.async("text").then(function(xmlContent) {
          processMusicXMLFile(xmlContent, fileName);
        }).catch(function(error) {
          console.error("Error reading score.xml:", error);
          showUploadStatus("Error reading score.xml from MXL file.", "error");
        });

      }).catch(function(error) {
        console.error("Error extracting MXL file:", error);
        showUploadStatus("Invalid MXL file format. Please check the file.", "error");
      });

    } catch (error) {
      console.error("Error processing MXL file:", error);
      showUploadStatus("Error processing MXL file. Please try a different file.", "error");
    }
  }

  function processMusicXMLFile(xmlContent, fileName) {
    try {
      // Basic validation - check if it's valid XML and contains MusicXML elements
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

      // Check for XML parsing errors
      const parseError = xmlDoc.getElementsByTagName("parsererror");
      if (parseError.length > 0) {
        showUploadStatus("Invalid XML file. Please check the file format.", "error");
        return;
      }

      // Check for MusicXML root elements
      const scorePartwise = xmlDoc.getElementsByTagName("score-partwise")[0];
      const scoreTimewise = xmlDoc.getElementsByTagName("score-timewise")[0];

      if (!scorePartwise && !scoreTimewise) {
        showUploadStatus("This doesn't appear to be a valid MusicXML file.", "error");
        return;
      }

      // Successfully parsed MusicXML
      showUploadStatus(`Successfully loaded: ${fileName}`, "success");

      // Store the XML content for later conversion
      window.uploadedMusicXML = {
        content: xmlContent,
        fileName: fileName,
        xmlDoc: xmlDoc
      };

      console.log("MusicXML file loaded successfully:", fileName);

      // Convert MusicXML to exercise format
      const exercise = convertMusicXMLToExercise(xmlDoc, fileName);
      if (exercise) {
        addExerciseToList(exercise);
        showUploadStatus(`Successfully converted: ${fileName} (${exercise.notes.length} notes)`, "success");
      }

    } catch (error) {
      console.error("Error processing MusicXML:", error);
      showUploadStatus("Error processing MusicXML file.", "error");
    }
  }

  function showUploadStatus(message, type) {
    uploadStatus.textContent = message;
    uploadStatus.className = `upload-status ${type}`;
  }

  function convertMusicXMLToExercise(xmlDoc, fileName) {
    try {
      // Extract basic info
      const scorePartwise = xmlDoc.getElementsByTagName("score-partwise")[0];
      const scoreTimewise = xmlDoc.getElementsByTagName("score-timewise")[0];
      const rootElement = scorePartwise || scoreTimewise;

      if (!rootElement) {
        showUploadStatus("Invalid MusicXML structure", "error");
        return null;
      }

      // Get title from various possible sources (in order of preference)
      let title = fileName.replace(/\.[^/.]+$/, ""); // Default to filename

      // First check credit-words (often contains the actual title)
      const creditWords = xmlDoc.getElementsByTagName("credit-words");
      for (let i = 0; i < creditWords.length; i++) {
        const creditText = creditWords[i].textContent?.trim();
        if (creditText &&
            creditText !== "Subtitle" &&
            creditText !== "Composer / arranger" &&
            creditText !== "Title" &&
            creditText.length > 3) {
          title = creditText;
          break;
        }
      }

      // Fallback to work-title or movement-title if no good credit-words found
      if (!title || title === fileName.replace(/\.[^/.]+$/, "")) {
        const workElement = xmlDoc.getElementsByTagName("work-title")[0];
        const movementTitle = xmlDoc.getElementsByTagName("movement-title")[0];
        const workTitle = workElement?.textContent?.trim();
        const moveTitle = movementTitle?.textContent?.trim();

        if (workTitle && workTitle !== "Untitled score" && workTitle !== "") {
          title = workTitle;
        } else if (moveTitle && moveTitle !== "") {
          title = moveTitle;
        }
      }

      // Get tempo (default to 120 if not found)
      let bpm = 120;
      const tempoElements = xmlDoc.getElementsByTagName("per-minute");
      if (tempoElements.length > 0) {
        bpm = parseInt(tempoElements[0].textContent) || 120;
      }

      // Extract notes and chords
      const notes = [];
      let currentBeat = 0;

      // Get all measures
      const measures = xmlDoc.getElementsByTagName("measure");

      for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
        const measure = measures[measureIndex];
        const noteElements = measure.getElementsByTagName("note");

        let i = 0;
        while (i < noteElements.length) {
          const noteElement = noteElements[i];

          // Skip rests
          if (noteElement.getElementsByTagName("rest").length > 0) {
            // Still need to advance timing for rests
            const duration = getDuration(noteElement);
            currentBeat += duration;
            i++;
            continue;
          }

          // Check if this is a chord (starts with a note that has chord tones following)
          const chordNotes = [];
          let currentNoteIndex = i;

          // Collect the first note
          const firstNote = parseNoteElement(noteElements[currentNoteIndex]);
          if (firstNote && firstNote.midi >= 40 && firstNote.midi <= 84) {
            chordNotes.push(firstNote);
          }
          currentNoteIndex++;

          // Collect any subsequent chord tones
          while (currentNoteIndex < noteElements.length) {
            const chordElement = noteElements[currentNoteIndex];

            // Check if this note has <chord/> element (indicating it's part of the chord)
            if (chordElement.getElementsByTagName("chord").length > 0) {
              const chordNote = parseNoteElement(chordElement);
              if (chordNote && chordNote.midi >= 40 && chordNote.midi <= 84) {
                chordNotes.push(chordNote);
              }
              currentNoteIndex++;
            } else {
              break; // No more chord tones
            }
          }

          // Create note event (single note or chord)
          if (chordNotes.length > 1) {
            // This is a chord - create chord event
            notes.push({
              beat: Math.round(currentBeat * 4) / 4,
              type: "chord",
              notes: chordNotes
            });
          } else if (chordNotes.length === 1) {
            // Single note
            notes.push({
              beat: Math.round(currentBeat * 4) / 4,
              midi: chordNotes[0].midi,
              string: chordNotes[0].string,
              fret: chordNotes[0].fret
            });
          }

          // Advance timing (use duration from first note)
          if (firstNote) {
            const duration = getDuration(noteElements[i]);
            currentBeat += duration;
          }

          // Move to next note group
          i = currentNoteIndex;
        }
      }

      // Helper function to parse individual note elements
      function parseNoteElement(noteElement) {
        // Get pitch
        const pitch = noteElement.getElementsByTagName("pitch")[0];
        if (!pitch) return null;

        const step = pitch.getElementsByTagName("step")[0]?.textContent;
        const alter = pitch.getElementsByTagName("alter")[0]?.textContent;
        const octave = pitch.getElementsByTagName("octave")[0]?.textContent;

        if (!step || !octave) return null;

        // Convert to MIDI note number
        const midiNote = pitchToMIDI(step, alter ? parseInt(alter) : 0, parseInt(octave));

        // Get guitar tablature info if available
        let string = null, fret = null;
        const technical = noteElement.getElementsByTagName("technical")[0];
        if (technical) {
          const stringEl = technical.getElementsByTagName("string")[0];
          const fretEl = technical.getElementsByTagName("fret")[0];
          if (stringEl) string = parseInt(stringEl.textContent);
          if (fretEl) fret = parseInt(fretEl.textContent);
        }

        return {
          midi: midiNote,
          step: step,
          alter: alter ? parseInt(alter) : 0,
          octave: parseInt(octave),
          string: string,
          fret: fret
        };
      }

      // Create exercise object
      const exercise = {
        name: title,
        description: `Converted from ${fileName}`,
        bpm: Math.min(Math.max(bpm, 40), 200), // Clamp between 40-200
        difficulty: notes.length > 30 ? "intermediate" : "beginner",
        notes: notes,
        isUploaded: true // Mark as uploaded to distinguish from built-in exercises
      };

      console.log("Converted exercise:", exercise);
      return exercise;

    } catch (error) {
      console.error("Error converting MusicXML to exercise:", error);
      showUploadStatus("Error converting MusicXML to exercise format", "error");
      return null;
    }
  }

  function getDuration(noteElement) {
    // Get duration in quarter notes (simplified)
    const durationElement = noteElement.getElementsByTagName("duration")[0];
    const typeElement = noteElement.getElementsByTagName("type")[0];

    if (durationElement) {
      // Duration is in divisions of a quarter note
      const duration = parseInt(durationElement.textContent);
      const divisions = 1; // Simplified - should get from attributes
      return duration / divisions / 4; // Convert to beats
    }

    if (typeElement) {
      const type = typeElement.textContent;
      const durations = {
        'whole': 4,
        'half': 2,
        'quarter': 1,
        'eighth': 0.5,
        '16th': 0.25,
        '32nd': 0.125
      };
      return durations[type] || 1;
    }

    return 1; // Default to quarter note
  }

  function pitchToMIDI(step, alter, octave) {
    // Convert note name to MIDI number
    const noteValues = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
    const baseNote = noteValues[step];
    return (octave + 1) * 12 + baseNote + (alter || 0);
  }

  function addExerciseToList(exercise) {
    // Add to available exercises array
    availableExercises.push(exercise);

    // Update the dropdown
    populateExerciseDropdown();

    // Automatically select the new exercise
    const exerciseSelect = $("exercise");
    exerciseSelect.value = exercise.name;

    // Load the exercise
    loadExercise(exercise);
  }
}

// Initialize upload functionality
setupMusicXMLUpload();
</script>
</body>
</html>
