<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tab Trainer (Monophonic)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { margin: 0 0 12px 0; }
    button, input, select { font-size: 16px; }
    button { padding: 10px 14px; }
    .row { display:flex; gap:16px; flex-wrap: wrap; align-items:center; }
    .panel { border:1px solid #ddd; border-radius:12px; padding:16px; min-width: 320px; }
    .big { font-size: 20px; font-weight: 650; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    label { display:block; font-size: 12px; opacity: 0.75; margin-bottom: 6px; }

    .notes { display:flex; gap:10px; flex-wrap: wrap; }
    .note {
      border:1px solid #ddd; border-radius:10px; padding:10px 12px; min-width:84px;
      text-align:center;
    }
    .note .t { font-size: 12px; opacity: 0.7; margin-top: 6px;}
    .note.hit { border-color: #1a7f37; }
    .note.miss { border-color: #b42318; }
    .note.next { border-width: 2px; }

    /* Guitar fretboard styles */
    .fretboard {
      position: relative;
      width: 100%;
      height: 280px;
      background: linear-gradient(to bottom, #2a2a2a 0%, #1a1a1a 100%);
      border-radius: 8px;
      overflow: hidden;
      margin-top: 12px;
    }

    .string {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #888;
      border-radius: 1px;
    }

    .string.e-high { top: 30px; }
    .string.b { top: 70px; }
    .string.g { top: 110px; }
    .string.d { top: 150px; }
    .string.a { top: 190px; }
    .string.e-low { top: 230px; }

    .hit-zone {
      position: absolute;
      left: 60px;
      top: 0;
      bottom: 0;
      width: 4px;
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
      z-index: 10;
      transition: all 0.2s ease;
    }

    .hit-zone.hit-feedback {
      background: #00ff00;
      box-shadow: 0 0 30px #00ff00, 0 0 60px #00ff00;
      width: 8px;
      transform: scaleY(1.2);
    }

    .hit-zone.miss-feedback {
      background: #ff4444;
      box-shadow: 0 0 30px #ff4444, 0 0 60px #ff4444;
      width: 8px;
      transform: scaleY(1.2);
    }

    /* Full-screen feedback overlay */
    .feedback-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    .feedback-overlay.hit {
      background: radial-gradient(circle, rgba(26, 127, 55, 0.3) 0%, rgba(26, 127, 55, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    .feedback-overlay.miss {
      background: radial-gradient(circle, rgba(180, 35, 24, 0.3) 0%, rgba(180, 35, 24, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    /* Enhanced fret note feedback */
    .fret-note.hit {
      background: #1a7f37;
      box-shadow: 0 0 25px #1a7f37, 0 0 50px #1a7f37;
      transform: translate(-50%, -50%) scale(1.3);
      border-color: #00ff00;
      border-width: 3px;
    }

    .fret-note.miss {
      background: #b42318;
      box-shadow: 0 0 25px #b42318, 0 0 50px #b42318;
      transform: translate(-50%, -50%) scale(1.3);
      border-color: #ff4444;
      border-width: 3px;
    }

    .fret-note {
      position: absolute;
      width: 32px;
      height: 32px;
      border-radius: 50%;
      border: 2px solid #fff;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: bold;
      color: #fff;
      background: #4a90e2;
      transform: translate(-50%, -50%);
      transition: all 0.1s ease;
      z-index: 5;
    }

    .fret-note.hit {
      background: #1a7f37;
      box-shadow: 0 0 15px #1a7f37;
    }

    .fret-note.miss {
      background: #b42318;
      box-shadow: 0 0 15px #b42318;
    }

    .string-label {
      position: absolute;
      left: 10px;
      transform: translateY(-50%);
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 3px #000;
    }

    .flash {
      outline: 3px solid #999;
      border-radius: 10px;
      padding: 4px 8px;
      display: inline-block;
    }

    progress { width: 100%; height: 18px; }
    .hint { opacity: 0.75; font-size: 13px; margin-top: 10px; line-height: 1.35; }
  </style>
</head>

<body>
  <h1>Tab Trainer (Single Notes)</h1>

  <div class="row">
    <button id="btnMic">Enable Mic</button>
    <button id="btnStart" disabled>Start</button>
    <button id="btnStop" disabled>Stop</button>
    <div class="mono" id="status" style="opacity:0.8;">—</div>
  </div>

  <div class="row" style="margin-top:16px;">
    <div class="panel" style="min-width:360px;">
      <div class="big">Tempo</div>

      <div style="margin-top:10px;">
        <label for="bpm">BPM</label>
        <div class="row" style="gap:10px;">
          <input id="bpm" type="range" min="40" max="200" value="90" />
          <input id="bpmNum" type="number" min="40" max="200" value="90" style="width:90px;" />
        </div>
      </div>

      <div style="margin-top:14px;">
        <label for="mode">Mode</label>
        <select id="mode">
          <option value="practice" selected>Practice (advance on correct note)</option>
          <option value="rhythm">Rhythm (must hit within window)</option>
        </select>
      </div>

      <div style="margin-top:14px;">
        <label>Metronome</label>
        <div class="row" style="gap:10px;">
          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="metroOn" type="checkbox" checked />
            On
          </label>

          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="countInOn" type="checkbox" checked />
            4-beat count-in
          </label>
        </div>
      </div>

      <div style="margin-top:16px;">
        <div class="big">Mic</div>
        <div id="micStatus" class="mono" style="margin-top:6px;">Not enabled</div>

        <div style="margin-top:12px;">
          <label>Input level</label>
          <progress id="level" value="0" max="1"></progress>
          <div id="levelText" class="mono" style="margin-top:6px;">rms=—</div>
        </div>

        <div style="margin-top:14px;">
          <div class="big">Last registered note</div>
          <div id="lastNote" class="mono" style="font-size:22px; margin-top:6px;">—</div>
          <div id="lastNoteMeta" class="mono" style="opacity:0.8; margin-top:6px;">—</div>
        </div>

        <div style="margin-top:14px;">
          <div class="big">Now</div>
          <div id="now" class="mono" style="margin-top:6px;">—</div>
        </div>

        <div class="hint">
          Debug tip: pluck one string cleanly (open A or D) and let it ring.
          Low E can be harder to detect.
        </div>
      </div>
    </div>

    <div class="panel" style="flex:1; min-width:360px;">
      <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 12px;">
        <div class="big">Guitar Tab</div>
        <div id="scoreDisplay" style="display: flex; gap: 16px; font-size: 16px; font-weight: bold;">
          <div style="color: #1a7f37;">✓ <span id="successCount">0</span></div>
          <div style="color: #b42318;">✗ <span id="failCount">0</span></div>
          <div style="color: #666;">Accuracy: <span id="accuracy">0%</span></div>
        </div>
      </div>
      <div class="fretboard" id="fretboard">
        <!-- String lines -->
        <div class="string e-high"></div>
        <div class="string b"></div>
        <div class="string g"></div>
        <div class="string d"></div>
        <div class="string a"></div>
        <div class="string e-low"></div>

        <!-- String labels -->
        <div class="string-label" style="top: 30px;">E</div>
        <div class="string-label" style="top: 70px;">B</div>
        <div class="string-label" style="top: 110px;">G</div>
        <div class="string-label" style="top: 150px;">D</div>
        <div class="string-label" style="top: 190px;">A</div>
        <div class="string-label" style="top: 230px;">E</div>

        <!-- Hit zone -->
        <div class="hit-zone"></div>
      </div>

      <!-- Fallback notes display for debugging (hidden by default) -->
      <div id="notes" class="notes" style="margin-top:12px; display: none;"></div>

      <div class="hint">
        Notes move from right to left. Play them when they reach the green line.
        Use Practice mode if you want it to advance when you hit the right note, regardless of timing.
      </div>
    </div>
  </div>

  <!-- Full-screen feedback overlay -->
  <div id="feedbackOverlay" class="feedback-overlay"></div>

<script>
/**
 * -------------------------
 * Song definition (beats)
 * -------------------------
 * You can later load this from your Go backend as JSON.
 */
const song = [
  { beat: 0, midi: 40 }, // E2
  { beat: 1, midi: 45 }, // A2
  { beat: 2, midi: 50 }, // D3
  { beat: 3, midi: 55 }, // G3
  { beat: 4, midi: 59 }, // B3
  { beat: 5, midi: 64 }, // E4
];

/**
 * -------------------------
 * Tuning knobs (MVP)
 * -------------------------
 */
const MIN_RMS = 0.003;       // gate for "is there sound?"
const STABLE_FRAMES = 2;     // require stable MIDI rounding for N frames
const CENTS_TOLERANCE = 40;  // pitch forgiveness
const COOLDOWN_SEC = 0.22;   // prevent double triggers on one note
const DEFAULT_BPM = 90;
const BEATS_PER_BAR = 4;

/**
 * -------------------------
 * Guitar fretboard constants
 * -------------------------
 */
const TUNING = [40, 45, 50, 55, 59, 64]; // MIDI values for standard tuning (E-A-D-G-B-E)
const STRING_NAMES = ["E", "A", "D", "G", "B", "E"];
const STRING_POSITIONS = [230, 190, 150, 110, 70, 30]; // Y positions for each string
const LOOKAHEAD_BEATS = 4;   // notes appear 4 beats early
const HIT_ZONE_X = 60;       // X position of hit zone
const NOTE_TRAVEL_DISTANCE = 400; // pixels notes travel
const MAX_FRET = 12;         // maximum fret to consider

const $ = (id) => document.getElementById(id);

function midiToName(midi) {
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const n = names[midi % 12];
  const oct = Math.floor(midi/12) - 1;
  return `${n}${oct}`;
}
function freqToMidi(freq) {
  return 69 + 12 * Math.log2(freq / 440);
}
function centsDiff(midiFloat, midiInt) {
  return (midiFloat - midiInt) * 100;
}
function secondsToBeats(seconds, bpm) {
  return (seconds * bpm) / 60;
}
function beatsToSeconds(beats, bpm) {
  return (beats * 60) / bpm;
}

/**
 * Convert MIDI note to guitar string and fret position
 * Returns { string: index, fret: number, y: pixel position } or null if unplayable
 */
function midiToFret(midiNote) {
  const candidates = [];

  // Check each string for possible fret positions
  for (let stringIdx = 0; stringIdx < TUNING.length; stringIdx++) {
    const openStringMidi = TUNING[stringIdx];
    const fret = midiNote - openStringMidi;

    // Must be a valid fret (0-MAX_FRET)
    if (fret >= 0 && fret <= MAX_FRET) {
      candidates.push({
        string: stringIdx,
        fret: fret,
        y: STRING_POSITIONS[stringIdx],
        stringName: STRING_NAMES[stringIdx]
      });
    }
  }

  if (candidates.length === 0) return null;

  // Prefer lower frets for easier playability
  // If multiple options, choose the one with lowest fret number
  candidates.sort((a, b) => a.fret - b.fret);
  return candidates[0];
}

/**
 * Timing window that adapts to tempo.
 * Wider at slow BPM so practice doesn't feel punishing.
 */
function timingWindowBeats(bpm) {
  // ~0.60 beats at 40 BPM, ~0.25 beats at 120 BPM, floor at 0.20
  return Math.max(0.20, Math.min(0.60, (120 / bpm) * 0.25));
}

/**
 * -------------------------
 * YIN pitch detector (monophonic)
 * -------------------------
 */
function yinPitch(buffer, sampleRate) {
  let rms = 0;
  for (let i = 0; i < buffer.length; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms / buffer.length);
  if (rms < MIN_RMS) return { freq: null, conf: 0, rms };

  const threshold = 0.12;
  const bufferSize = buffer.length;
  const maxTau = Math.floor(sampleRate / 50);
  const minTau = Math.floor(sampleRate / 1000);

  const d = new Float32Array(maxTau + 1);
  for (let tau = minTau; tau <= maxTau; tau++) {
    let sum = 0;
    const maxI = Math.max(0, bufferSize - tau);
    for (let i = 0; i < maxI; i++) {
      const delta = buffer[i] - buffer[i + tau];
      sum += delta * delta;
    }
    d[tau] = sum;
  }

  const cmndf = new Float32Array(maxTau + 1);
  cmndf[0] = 1;
  let runningSum = 0;
  for (let tau = 1; tau <= maxTau; tau++) {
    runningSum += d[tau];
    cmndf[tau] = runningSum === 0 ? 1 : d[tau] * tau / runningSum;
  }

  let tauEstimate = -1;
  for (let tau = minTau; tau <= maxTau; tau++) {
    if (tau < cmndf.length && cmndf[tau] < threshold) {
      while (tau + 1 <= maxTau && tau + 1 < cmndf.length && cmndf[tau + 1] < cmndf[tau]) tau++;
      tauEstimate = tau;
      break;
    }
  }
  if (tauEstimate === -1 || tauEstimate >= cmndf.length) return { freq: null, conf: 0, rms };

  // Parabolic interpolation
  const x0 = tauEstimate > 1 ? tauEstimate - 1 : tauEstimate;
  const x2 = tauEstimate + 1 <= maxTau && tauEstimate + 1 < cmndf.length ? tauEstimate + 1 : tauEstimate;

  const s0 = x0 < cmndf.length ? cmndf[x0] : 1;
  const s1 = tauEstimate < cmndf.length ? cmndf[tauEstimate] : 1;
  const s2 = x2 < cmndf.length ? cmndf[x2] : 1;

  const a = (s0 + s2 - 2 * s1) / 2;
  const b = (s2 - s0) / 2;
  const betterTau = (Math.abs(a) > 1e-10) ? (tauEstimate - b / (2 * a)) : tauEstimate;

  const freq = sampleRate / betterTau;
  const conf = Math.max(0, Math.min(1, 1 - cmndf[tauEstimate]));
  return { freq, conf, rms };
}

/**
 * Octave correction: if detector locks on a harmonic (octave up/down),
 * choose the octave variant closest to expected MIDI.
 */
function octaveCorrect(playedFreq, expectedMidi) {
  const playedMidi = freqToMidi(playedFreq);
  const candidates = [
    playedMidi,
    playedMidi - 12,
    playedMidi + 12,
  ];

  let best = candidates[0];
  let bestAbs = Math.abs(centsDiff(candidates[0], expectedMidi));
  for (const c of candidates) {
    const a = Math.abs(centsDiff(c, expectedMidi));
    if (a < bestAbs) { bestAbs = a; best = c; }
  }
  return { correctedMidi: best, centsOff: centsDiff(best, expectedMidi) };
}

/**
 * -------------------------
 * Visual notes management
 * -------------------------
 */
function clearVisualNotes() {
  for (const [noteId, noteData] of state.visualNotes) {
    if (noteData.element && noteData.element.parentNode) {
      noteData.element.remove();
    }
  }
  state.visualNotes.clear();
  state.nextNoteId = 0;
}

function createVisualNote(eventData, fretInfo) {
  const noteId = state.nextNoteId++;
  const fretboard = $("fretboard");

  const noteElement = document.createElement("div");
  noteElement.className = "fret-note";
  noteElement.textContent = fretInfo.fret === 0 ? "0" : fretInfo.fret.toString();

  // Start position (right side of fretboard)
  const startX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE;
  noteElement.style.left = startX + "px";
  noteElement.style.top = fretInfo.y + "px";

  fretboard.appendChild(noteElement);

  const noteData = {
    element: noteElement,
    eventData: eventData,
    fretInfo: fretInfo,
    noteId: noteId,
    spawned: false
  };

  state.visualNotes.set(noteId, noteData);
  return noteData;
}

function updateVisualNotes(beatNow) {
  const fretboard = $("fretboard");
  const notesToRemove = [];

  // Spawn new notes that should be visible
  for (const event of state.events) {
    if (!event.visualNote && beatNow >= event.beat - LOOKAHEAD_BEATS && !event.judged) {
      const fretInfo = midiToFret(event.midi);
      if (fretInfo) {
        const noteData = createVisualNote(event, fretInfo);
        event.visualNote = noteData;
        noteData.spawned = true;
      }
    }
  }

  // Update positions of existing notes
  for (const [noteId, noteData] of state.visualNotes) {
    const event = noteData.eventData;
    const timeToHit = event.beat - beatNow;

    // Calculate position based on remaining time
    const progress = (LOOKAHEAD_BEATS - timeToHit) / LOOKAHEAD_BEATS;
    const currentX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE * (1 - progress);

    noteData.element.style.left = currentX + "px";

    // Update visual state based on hit/miss
    if (event.hit && !noteData.element.classList.contains("hit")) {
      noteData.element.classList.add("hit");
    }
    if (event.miss && !noteData.element.classList.contains("miss")) {
      noteData.element.classList.add("miss");
    }

    // Remove notes that have passed the hit zone
    if (timeToHit < -1) { // 1 beat grace period after missing
      notesToRemove.push(noteId);
    }
  }

  // Clean up old notes
  for (const noteId of notesToRemove) {
    const noteData = state.visualNotes.get(noteId);
    if (noteData && noteData.element && noteData.element.parentNode) {
      noteData.element.remove();
    }
    state.visualNotes.delete(noteId);
  }
}

function updateScoreDisplay() {
  $("successCount").textContent = state.successCount;
  $("failCount").textContent = state.failCount;

  const total = state.successCount + state.failCount;
  const accuracy = total === 0 ? 0 : Math.round((state.successCount / total) * 100);
  $("accuracy").textContent = accuracy + "%";
}

function showHitZoneFeedback(isHit) {
  const hitZone = $("fretboard").querySelector(".hit-zone");

  // Remove any existing feedback classes
  hitZone.classList.remove("hit-feedback", "miss-feedback");

  // Add appropriate feedback class
  if (isHit) {
    hitZone.classList.add("hit-feedback");
  } else {
    hitZone.classList.add("miss-feedback");
  }

  // Remove feedback after animation
  setTimeout(() => {
    hitZone.classList.remove("hit-feedback", "miss-feedback");
  }, 300);
}

function showFullScreenFeedback(isHit) {
  const overlay = $("feedbackOverlay");

  // Remove any existing feedback classes
  overlay.classList.remove("hit", "miss");

  // Add appropriate feedback class
  if (isHit) {
    overlay.classList.add("hit");
  } else {
    overlay.classList.add("miss");
  }

  // Remove feedback after animation
  setTimeout(() => {
    overlay.classList.remove("hit", "miss");
  }, 200);
}

/**
 * -------------------------
 * Rendering
 * -------------------------
 */
function renderNotes() {
  const root = $("notes");
  root.innerHTML = "";

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    const div = document.createElement("div");

    let cls = "note";
    if (i === state.nextIdx) cls += " next";
    if (ev.hit) cls += " hit";
    if (ev.miss) cls += " miss";

    div.className = cls;
    div.innerHTML = `
      <div class="mono">${midiToName(ev.midi)}</div>
      <div class="t mono">beat=${ev.beat.toFixed(2)}</div>
    `;
    root.appendChild(div);
  }
}

/**
 * -------------------------
 * Matching logic
 * -------------------------
 */
function getNextUnhitIndex() {
  return state.events.findIndex(ev => !ev.hit && !ev.miss);
}

function judgeMisses(beatNow) {
  const win = timingWindowBeats(state.bpm);

  for (const ev of state.events) {
    if (!ev.judged && beatNow > ev.beat + win) {
      ev.miss = !ev.hit;
      ev.judged = true;

      // Count timing misses in score
      if (ev.miss && !ev.hit) {
        state.failCount++;
        updateScoreDisplay();

        // Show miss feedback (less dramatic since it's a timing miss)
        showHitZoneFeedback(false);
      }
    }
  }

  const idx = getNextUnhitIndex();
  state.nextIdx = idx === -1 ? state.events.length - 1 : idx;
}

/**
 * Returns a verdict object for UI:
 * - practice mode: always compares against NEXT note
 * - rhythm mode: compares against nearest note within timing window
 */
function tryMatchPlayed(beatNow, playedFreq) {
  const mode = state.mode; // "practice" | "rhythm"

  let idx = -1;

  if (mode === "practice") {
    idx = getNextUnhitIndex();
    if (idx === -1) return null;
  } else {
    // rhythm mode: find nearest unhit note within window
    const win = timingWindowBeats(state.bpm);
    let bestDb = Infinity;

    for (let i = 0; i < state.events.length; i++) {
      const ev = state.events[i];
      if (ev.hit) continue; // allow retries until missed
      const db = Math.abs(beatNow - ev.beat);
      if (db <= win && db < bestDb) {
        bestDb = db;
        idx = i;
      }
    }
    if (idx === -1) return null;
  }

  const ev = state.events[idx];

  const { correctedMidi, centsOff } = octaveCorrect(playedFreq, ev.midi);
  const ok = Math.abs(centsOff) <= CENTS_TOLERANCE;

  // timing info (informational in practice mode)
  const timingBeats = beatNow - ev.beat;

  if (ok) {
    ev.hit = true;
    ev.judged = true;
  }

  return {
    ok,
    expected: ev.midi,
    detected: correctedMidi,
    centsOff,
    timingBeats,
    expectedBeat: ev.beat,
    mode
  };
}

/**
 * -------------------------
 * Metronome (click on beat)
 * -------------------------
 * Uses AudioContext oscillator for a short "tick".
 * Downbeat is higher frequency.
 */
function metroTick(isDownbeat) {
  if (!state.audioCtx) return;
  const ctx = state.audioCtx;

  // Duck detection briefly after we emit the tick (prevents mic hearing the click)
  state.ignoreUntil = Math.max(state.ignoreUntil, ctx.currentTime + 0.12);

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";
  osc.frequency.value = isDownbeat ? 1200 : 880;

  const t = ctx.currentTime;
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(0.20, t + 0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start(t);
  osc.stop(t + 0.07);
}


/**
 * -------------------------
 * App state
 * -------------------------
 */
const state = {
  audioCtx: null,
  analyser: null,
  micStream: null,
  rafId: null,

  practicing: false,

  bpm: DEFAULT_BPM,
  mode: "practice",

  // time model:
  // beatNow = secondsToBeats(audioCtx.currentTime - startTime, bpm)
  startTime: 0,

  // metronome scheduler:
  lastMetroBeat: -1,
  nextMetroTime: 0,

  // detection stability:
  stableCount: 0,
  lastMidiRounded: null,
  lastTriggerAt: 0,

  // song events:
  events: song.map(e => ({...e, hit:false, miss:false, judged:false, visualNote:null })),
  nextIdx: 0,

  // visual notes on fretboard
  visualNotes: new Map(),  // noteId -> visual note element
  nextNoteId: 0,

  // score tracking
  successCount: 0,
  failCount: 0,

  ignoreUntil: 0,          // audioCtx time until which we ignore detection (ducking)
  lastRms: 0,              // optional: simple onset gating baseline
};

function resetPractice() {
  state.practicing = false;
  state.startTime = 0;
  state.lastMetroBeat = -1;
  state.nextMetroTime = 0;

  state.stableCount = 0;
  state.lastMidiRounded = null;
  state.lastTriggerAt = 0;

  state.events = song.map(e => ({...e, hit:false, miss:false, judged:false, visualNote:null }));
  state.nextIdx = 0;

  // Clear visual notes
  clearVisualNotes();

  // Reset score counters
  state.successCount = 0;
  state.failCount = 0;
  updateScoreDisplay();

  $("now").textContent = "—";
  $("lastNote").textContent = "—";
  $("lastNoteMeta").textContent = "—";
  $("status").textContent = "ready";
  renderNotes();
}

function currentBeat(nowAudioTime) {
  const elapsed = nowAudioTime - state.startTime;
  return secondsToBeats(elapsed, state.bpm);
}

/**
 * -------------------------
 * Main loop
 * -------------------------
 */
function loop() {
  if (!state.practicing) return;

  const now = state.audioCtx.currentTime;
  const beatNow = currentBeat(now);

  // Ignore detection briefly after metronome tick (prevents self-triggering)
  if (now < state.ignoreUntil) {
    state.rafId = requestAnimationFrame(loop);
    return;
  }

  // Count-in handling (beatNow < 0 means we're counting in)
  if (beatNow < 0) {
    $("now").textContent = `count-in… beat=${beatNow.toFixed(2)} @ ${state.bpm} BPM`;
  } else {
    $("now").textContent = `beat=${beatNow.toFixed(3)} @ ${state.bpm} BPM`;
  }

  // Metronome tick (including count-in if enabled) with precise timing
  if ($("metroOn").checked) {
    if (now >= state.nextMetroTime && state.nextMetroTime > 0) {
      const currentBeatInt = Math.floor(beatNow);

      // Determine downbeat within bars (handles negative beats too)
      const barPos = ((currentBeatInt % BEATS_PER_BAR) + BEATS_PER_BAR) % BEATS_PER_BAR;
      const isDownbeat = (barPos === 0);
      metroTick(isDownbeat);

      // Schedule next tick precisely
      const beatDuration = beatsToSeconds(1, state.bpm);
      state.nextMetroTime += beatDuration;

      // Prevent accumulating drift by resetting if we get too far behind
      if (state.nextMetroTime < now - beatDuration) {
        state.nextMetroTime = now + beatDuration;
      }
    }
  }

  // Read mic samples
  const buf = new Float32Array(state.analyser.fftSize);
  state.analyser.getFloatTimeDomainData(buf);

  const { freq, conf, rms } = yinPitch(buf, state.audioCtx.sampleRate);
  
  // crude onset: require a jump in level vs previous frame (helps ignore steady speech/background)
  const onset = rms > Math.max(0.01, state.lastRms * 1.8);
  state.lastRms = 0.9 * state.lastRms + 0.1 * rms; // smooth baseline
  

  // UI: input level / debug
  $("level").value = Math.min(1, rms * 20);
  $("levelText").textContent =
    `rms=${rms.toFixed(4)} conf=${conf.toFixed(2)} freq=${freq ? freq.toFixed(1) : "—"}`;

  // Update visual notes animation
  updateVisualNotes(beatNow);

  // If we're still in count-in, do not judge notes (but still show detected pitch)
  if (beatNow < 0) {
    state.rafId = requestAnimationFrame(loop);
    return;
  }

  // Pitch → MIDI
  let midiFloat = null;
  let midiRounded = null;

  if (freq) {
    midiFloat = freqToMidi(freq);
    midiRounded = Math.round(midiFloat);
  }

  // Stability gate
  if (midiRounded !== null) {
    if (state.lastMidiRounded === midiRounded) state.stableCount++;
    else { state.lastMidiRounded = midiRounded; state.stableCount = 1; }
  } else {
    state.lastMidiRounded = null;
    state.stableCount = 0;
  }

  // Trigger gate
  const canTrigger = (now - state.lastTriggerAt) > COOLDOWN_SEC;

  if (freq && conf >= 0.65 && onset && midiFloat !== null && state.stableCount >= STABLE_FRAMES && canTrigger) {
    state.lastTriggerAt = now;

    // Match against tab
    const verdict = tryMatchPlayed(beatNow, freq);

    // UI: show detected note
    $("lastNote").textContent = midiToName(midiRounded);
    $("lastNote").classList.add("flash");

    if (verdict) {
      const detectedName = midiToName(Math.round(verdict.detected));
      const expectedName = midiToName(verdict.expected);

      $("lastNoteMeta").textContent =
        `mode=${verdict.mode} expected=${expectedName} detected≈${detectedName} ` +
        `cents=${verdict.centsOff.toFixed(1)} ` +
        `Δbeat=${verdict.timingBeats.toFixed(2)} (win≈${timingWindowBeats(state.bpm).toFixed(2)})`;

      $("lastNote").style.outlineColor = verdict.ok ? "#1a7f37" : "#b42318";
      $("status").textContent = verdict.ok ? "✓ correct" : "✗ wrong";

      // Update score counters
      if (verdict.ok) {
        state.successCount++;
      } else {
        state.failCount++;
      }
      updateScoreDisplay();

      // Show enhanced visual feedback
      showHitZoneFeedback(verdict.ok);
      showFullScreenFeedback(verdict.ok);
    } else {
      $("lastNoteMeta").textContent = `no expected note to match (try Practice mode)`;
      $("lastNote").style.outlineColor = "#999";
      $("status").textContent = "no match";
    }

    setTimeout(() => $("lastNote").classList.remove("flash"), 200);

    // Update progression
    judgeMisses(beatNow);
    renderNotes();
  } else {
    // still update misses over time in rhythm mode
    if (state.mode === "rhythm") {
      judgeMisses(beatNow);
      renderNotes();
    }
  }

  state.rafId = requestAnimationFrame(loop);
}

/**
 * -------------------------
 * Controls
 * -------------------------
 */
function setBpm(bpm) {
  bpm = Math.max(40, Math.min(200, Number(bpm)));
  state.bpm = bpm;
  $("bpm").value = bpm;
  $("bpmNum").value = bpm;
}

$("bpm").addEventListener("input", (e) => setBpm(e.target.value));
$("bpmNum").addEventListener("change", (e) => setBpm(e.target.value));
$("mode").addEventListener("change", (e) => {
  state.mode = e.target.value;
  $("status").textContent = `mode=${state.mode}`;
});

$("btnMic").addEventListener("click", async () => {
  try {
    if (state.audioCtx || state.micStream) {
      console.log("Microphone already initialized");
      return;
    }

    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Request mic
    state.micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
      }
    });

    const src = state.audioCtx.createMediaStreamSource(state.micStream);

    // Bigger window helps low notes (E2)
    state.analyser = state.audioCtx.createAnalyser();
    state.analyser.fftSize = 8192;

    src.connect(state.analyser);

    $("micStatus").textContent = "Enabled ✓ (listening)";
    $("status").textContent = "mic ready";
    $("btnStart").disabled = false;
    $("btnMic").textContent = "Mic Enabled ✓";
    $("btnMic").disabled = true;
  } catch (e) {
    let errorMessage = "Unknown error";
    let statusMessage = "mic error";

    if (e.name === "NotAllowedError") {
      errorMessage = "Microphone permission denied. Please allow microphone access and try again.";
      statusMessage = "permission denied";
    } else if (e.name === "NotFoundError") {
      errorMessage = "No microphone found. Please connect a microphone and try again.";
      statusMessage = "no microphone";
    } else if (e.name === "NotReadableError") {
      errorMessage = "Microphone in use by another application. Please close other apps and try again.";
      statusMessage = "mic busy";
    } else if (e.name === "OverconstrainedError") {
      errorMessage = "Microphone doesn't support required settings. Trying with default settings...";
      statusMessage = "retrying...";
      // Try again with less strict constraints
      try {
        state.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const src = state.audioCtx.createMediaStreamSource(state.micStream);
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = 8192;
        src.connect(state.analyser);

        $("micStatus").textContent = "Enabled ✓ (basic settings)";
        $("status").textContent = "mic ready";
        $("btnStart").disabled = false;
        $("btnMic").textContent = "Mic Enabled ✓";
        $("btnMic").disabled = true;
        return;
      } catch (retryError) {
        errorMessage = `Microphone failed: ${retryError?.message || retryError}`;
        statusMessage = "mic failed";
      }
    } else {
      errorMessage = `Microphone error: ${e?.message || e}`;
    }

    $("micStatus").textContent = errorMessage;
    $("status").textContent = statusMessage;
    console.error("Microphone initialization failed:", e);

    // Reset state on error
    state.audioCtx = null;
    state.micStream = null;
    state.analyser = null;
  }
});

$("btnStart").addEventListener("click", async () => {
  if (!state.audioCtx) return;

  // Ensure AudioContext is running (some browsers need a user gesture)
  if (state.audioCtx.state === "suspended") {
    await state.audioCtx.resume();
  }

  resetPractice();

  state.practicing = true;

  const useCountIn = $("countInOn").checked;
  const countInBeats = useCountIn ? BEATS_PER_BAR : 0;

  // Set start time in the future so beatNow starts negative (count-in)
  state.startTime = state.audioCtx.currentTime + beatsToSeconds(countInBeats, state.bpm);

  // Schedule first metronome tick precisely
  const beatDuration = beatsToSeconds(1, state.bpm);
  state.nextMetroTime = state.audioCtx.currentTime + beatDuration;

  $("btnStop").disabled = false;
  $("btnStart").disabled = true;
  $("status").textContent = useCountIn ? "count-in…" : "running";

  state.rafId = requestAnimationFrame(loop);
});

$("btnStop").addEventListener("click", () => {
  state.practicing = false;

  // Cancel animation frame
  if (state.rafId) {
    cancelAnimationFrame(state.rafId);
    state.rafId = null;
  }

  // Reset practice state
  resetPractice();

  // Clean up visual notes
  clearVisualNotes();

  // Clean up audio resources (but keep mic enabled for quick restart)
  if (state.audioCtx && state.audioCtx.state !== "closed") {
    // Don't close the AudioContext to avoid reinitialization overhead
    // Just stop any scheduled audio
    state.ignoreUntil = 0;
    state.nextMetroTime = 0;
  }

  // Update UI
  $("btnStop").disabled = true;
  $("btnStart").disabled = false;
  $("status").textContent = "stopped";

  // Clear detection displays
  $("lastNote").textContent = "—";
  $("lastNoteMeta").textContent = "—";
  $("now").textContent = "—";
  if ($("lastNote").classList.contains("flash")) {
    $("lastNote").classList.remove("flash");
  }
});

// Initial render
setBpm(DEFAULT_BPM);
renderNotes();
updateScoreDisplay();
$("status").textContent = "ready";
</script>
</body>
</html>
