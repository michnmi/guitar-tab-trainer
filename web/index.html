<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tab Trainer (Monophonic)</title>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { margin: 0 0 12px 0; }
    button, input, select { font-size: 16px; }
    button { padding: 10px 14px; }
    .row { display:flex; gap:16px; flex-wrap: wrap; align-items:center; }
    .panel { border:1px solid #ddd; border-radius:12px; padding:16px; min-width: 320px; }
    .big { font-size: 20px; font-weight: 650; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    label { display:block; font-size: 12px; opacity: 0.75; margin-bottom: 6px; }

    /* File upload styles */
    .upload-section {
      border: 2px dashed #ddd;
      border-radius: 8px;
      padding: 16px;
      margin: 16px 0;
      text-align: center;
      background: #f9f9f9;
      transition: all 0.2s ease;
    }
    .upload-section.dragover {
      border-color: #007bff;
      background: #e6f3ff;
    }
    .upload-section input[type="file"] {
      margin: 8px 0;
    }
    .upload-status {
      margin-top: 8px;
      font-size: 14px;
    }
    .upload-status.success {
      color: #1a7f37;
    }
    .upload-status.error {
      color: #b42318;
    }

    .notes { display:flex; gap:10px; flex-wrap: wrap; }
    .note {
      border:1px solid #ddd; border-radius:10px; padding:10px 12px; min-width:84px;
      text-align:center;
    }
    .note .t { font-size: 12px; opacity: 0.7; margin-top: 6px;}
    .note.hit { border-color: #1a7f37; }
    .note.miss { border-color: #b42318; }
    .note.skipped { border-color: #ff9900; opacity: 0.7; }
    .note.next { border-width: 2px; }

    /* Guitar fretboard styles */
    .fretboard {
      position: relative;
      width: 100%;
      height: 420px;
      background: linear-gradient(to bottom, #2a2a2a 0%, #1a1a1a 100%);
      border-radius: 8px;
      overflow: hidden;
      margin-top: 12px;
    }

    .string {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #888;
      border-radius: 1px;
    }

    .string.e-high { top: 45px; }
    .string.b { top: 105px; }
    .string.g { top: 165px; }
    .string.d { top: 225px; }
    .string.a { top: 285px; }
    .string.e-low { top: 345px; }

    .hit-zone {
      position: absolute;
      left: 60px;
      top: 0;
      bottom: 0;
      width: 4px;
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
      z-index: 10;
      transition: all 0.2s ease;
    }

    .hit-zone.hit-feedback {
      background: #00ff00;
      box-shadow: 0 0 30px #00ff00, 0 0 60px #00ff00;
      width: 8px;
      transform: scaleY(1.2);
    }

    .hit-zone.miss-feedback {
      background: #ff4444;
      box-shadow: 0 0 30px #ff4444, 0 0 60px #ff4444;
      width: 8px;
      transform: scaleY(1.2);
    }

    .hit-zone.skip-feedback {
      background: #ff9900;
      box-shadow: 0 0 20px #ff9900, 0 0 40px #ff9900;
      width: 6px;
      transform: scaleY(1.1);
    }

    /* Full-screen feedback overlay */
    .feedback-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    .feedback-overlay.hit {
      background: radial-gradient(circle, rgba(26, 127, 55, 0.3) 0%, rgba(26, 127, 55, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    .feedback-overlay.miss {
      background: radial-gradient(circle, rgba(180, 35, 24, 0.3) 0%, rgba(180, 35, 24, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    /* Enhanced fret note feedback */
    .fret-note.hit {
      background: #1a7f37;
      box-shadow: 0 0 25px #1a7f37, 0 0 50px #1a7f37;
      transform: translateY(-50%) scaleY(1.3);
      border-color: #00ff00;
      border-width: 3px;
    }

    .fret-note.miss {
      background: #b42318;
      box-shadow: 0 0 25px #b42318, 0 0 50px #b42318;
      transform: translateY(-50%) scaleY(1.3);
      border-color: #ff4444;
      border-width: 3px;
    }

    .fret-note.skipped {
      background: #ff9900;
      box-shadow: 0 0 15px #ff9900, 0 0 30px #ff9900;
      transform: translateY(-50%) scaleY(1.1);
      border-color: #ffaa33;
      border-width: 2px;
      opacity: 0.7;
    }

    .fret-note {
      position: absolute;
      min-width: 80px;
      height: 56px;
      border-radius: 16px;
      border: 5px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 900;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      color: #000;
      background: linear-gradient(145deg, #ffffff, #f0f0f0);
      transform: translateY(-50%);
      transition: none;
      z-index: 5;
      box-sizing: border-box;
      text-shadow:
        1px 1px 2px rgba(255,255,255,0.9),
        -1px -1px 2px rgba(255,255,255,0.9),
        2px 2px 4px rgba(0,0,0,0.3);
      box-shadow:
        0 0 0 2px #333,
        0 6px 20px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.8);
      will-change: transform;
      /* Anti-motion-blur techniques */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: geometricPrecision;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform-style: preserve-3d;
      /* Force hardware acceleration for smoother movement */
      -webkit-transform: translateZ(0) translateY(-50%);
      transform: translateZ(0) translateY(-50%);
      /* Prevent subpixel rendering issues and ensure crisp text */
      -webkit-transform: translate3d(0, -50%, 0);
      transform: translate3d(0, -50%, 0);
      /* Snap to pixel boundaries for crisp rendering */
      image-rendering: crisp-edges;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-optimize-contrast;
      /* Ensure text stays sharp during animation */
      -webkit-font-feature-settings: "liga" 0;
      font-feature-settings: "liga" 0;
    }

    .fret-note.open-string {
      background: linear-gradient(145deg, #9370db, #6a5acd);
      color: #fff;
      border-color: #4b0082;
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .fret-note.hit {
      background: linear-gradient(145deg, #22c55e, #16a34a);
      color: #fff;
      border-color: #15803d;
      box-shadow:
        0 0 0 2px #15803d,
        0 0 25px #22c55e,
        0 6px 20px rgba(0,0,0,0.4);
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .fret-note.miss {
      background: linear-gradient(145deg, #ef4444, #dc2626);
      color: #fff;
      border-color: #b91c1c;
      box-shadow:
        0 0 0 2px #b91c1c,
        0 0 25px #ef4444,
        0 6px 20px rgba(0,0,0,0.4);
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .string-label {
      position: absolute;
      left: 10px;
      transform: translateY(-50%);
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 3px #000;
    }

    .flash {
      outline: 3px solid #999;
      border-radius: 10px;
      padding: 4px 8px;
      display: inline-block;
    }

    progress { width: 100%; height: 18px; }
    .hint { opacity: 0.75; font-size: 13px; margin-top: 10px; line-height: 1.35; }
  </style>
</head>

<body>
  <h1>Tab Trainer (Single Notes)</h1>

  <!-- Technical Controls at Top -->
  <div class="panel" style="margin-bottom: 20px;">
    <div class="row">
      <button id="btnMic">Enable Mic</button>
      <button id="btnStart" disabled>Start</button>
      <button id="btnStop" disabled>Stop</button>
      <div class="mono" id="status" style="opacity:0.8;">‚Äî</div>
    </div>

    <div class="row" style="margin-top:16px; gap:32px; flex-wrap:wrap;">
      <!-- Exercise Controls -->
      <div style="min-width:200px;">
        <div style="margin-bottom:10px;">
          <label for="exercise">Exercise</label>
          <select id="exercise">
            <option value="">Loading exercises...</option>
          </select>
        </div>
      </div>

      <!-- MusicXML Upload -->
      <div style="min-width:300px;">
        <label>Upload MusicXML File</label>
        <div class="upload-section" id="uploadSection">
          <div>Drop a MusicXML file here or</div>
          <input type="file" id="musicxmlFile" accept=".mxl,.xml,.musicxml" />
          <div class="upload-status" id="uploadStatus"></div>
        </div>
      </div>

      <!-- Tempo Controls -->
      <div style="min-width:220px;">
        <label for="bpm">BPM</label>
        <div class="row" style="gap:10px;">
          <input id="bpm" type="range" min="40" max="200" value="90" />
          <input id="bpmNum" type="number" min="40" max="200" value="90" style="width:90px;" />
        </div>
        <div style="margin-top:10px;">
          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="metroOn" type="checkbox" checked />
            Metronome
          </label>
          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="countInOn" type="checkbox" checked />
            4-beat count-in
          </label>
        </div>
      </div>

      <!-- Microphone Status -->
      <div style="min-width:180px;">
        <div id="micStatus" class="mono" style="margin-bottom:6px;">Not enabled</div>
        <progress id="level" value="0" max="1" style="width:100%; margin-bottom:4px;"></progress>
        <div id="levelText" class="mono" style="font-size:12px;">rms=‚Äî</div>
      </div>

      <!-- Detection Status -->
      <div style="min-width:160px;">
        <div style="margin-bottom:4px;">
          <strong>Last Note:</strong>
          <div id="lastNote" class="mono" style="font-size:18px;">‚Äî</div>
        </div>
        <div id="now" class="mono" style="font-size:12px;">‚Äî</div>
      </div>
    </div>
  </div>

  <!-- Main Fretboard Display -->
  <div class="panel" style="width: 100%; margin-bottom: 12px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <div class="big">Guitar Fretboard</div>
      <div id="scoreDisplay" style="display: flex; gap: 20px; font-size: 18px; font-weight: bold;">
        <div style="color: #1a7f37;">‚úì <span id="successCount">0</span></div>
        <div style="color: #b42318;">‚úó <span id="failCount">0</span></div>
        <div style="color: #ff9900;">‚äù <span id="skippedCount">0</span></div>
        <div style="color: #666;">Accuracy: <span id="accuracy">0%</span></div>
      </div>
    </div>

    <div class="fretboard" id="fretboard">
      <!-- String lines -->
      <div class="string e-high"></div>
      <div class="string b"></div>
      <div class="string g"></div>
      <div class="string d"></div>
      <div class="string a"></div>
      <div class="string e-low"></div>

      <!-- String labels -->
      <div class="string-label" style="top: 45px;">E</div>
      <div class="string-label" style="top: 105px;">B</div>
      <div class="string-label" style="top: 165px;">G</div>
      <div class="string-label" style="top: 225px;">D</div>
      <div class="string-label" style="top: 285px;">A</div>
      <div class="string-label" style="top: 345px;">E</div>

      <!-- Hit zone -->
      <div class="hit-zone"></div>
    </div>

    <!-- Fallback notes display for debugging (hidden by default) -->
    <div id="notes" class="notes" style="margin-top:12px; display: none;"></div>

    <div class="hint">
      Notes move from right to left. Play them when the left edge reaches the green line.
    </div>
  </div>

  <!-- Debug Info (Collapsible) -->
  <details class="panel" style="margin-top: 12px;">
    <summary style="cursor: pointer; font-weight: bold;">Debug Information</summary>
    <div style="margin-top: 12px;">
      <div id="lastNoteMeta" class="mono" style="opacity:0.8; font-size:12px; margin-bottom:8px;">‚Äî</div>

      <!-- Enhanced Debug Log -->
      <div style="margin-top: 12px;">
        <div style="font-weight: bold; margin-bottom: 8px;">Debug Log (all events):</div>
        <div id="debugLog" class="mono" style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 8px; font-size: 10px; max-height: 200px; overflow-y: auto;">
          <div style="opacity: 0.6;">Debug information will appear here when notes are played...</div>
        </div>
        <button id="clearDebug" style="margin-top: 8px; padding: 4px 8px; font-size: 12px;">Clear Log</button>
        <button id="copyDebug" style="margin-top: 8px; margin-left: 8px; padding: 4px 8px; font-size: 12px;">Copy to Clipboard</button>
      </div>

      <div class="hint" style="margin-top: 12px;">
        Debug tip: pluck one string cleanly (open A or D) and let it ring.
        Low E can be harder to detect.
      </div>
    </div>
  </details>

  <!-- Practice History -->
  <details class="panel" style="margin-top: 12px;">
    <summary style="cursor: pointer; font-weight: bold;">Practice History</summary>
    <div style="margin-top: 12px;">
      <div id="practiceHistory" style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 8px; font-size: 12px; max-height: 300px; overflow-y: auto;">
        <div style="opacity: 0.6; text-align: center; padding: 20px;">No practice sessions yet. Complete an exercise to see your history!</div>
      </div>
      <button id="clearHistory" style="margin-top: 8px; padding: 4px 8px; font-size: 12px;">Clear History</button>
    </div>
  </details>

  <!-- Full-screen feedback overlay -->
  <div id="feedbackOverlay" class="feedback-overlay"></div>

<script>
/**
 * -------------------------
 * Exercise management
 * -------------------------
 */
let availableExercises = [];
let currentExercise = null;

// Default fallback exercise (same as original hardcoded)
const defaultExercise = {
  name: "Basic Strings",
  description: "Learn the open strings: E-A-D-G-B-E",
  bpm: 90,
  difficulty: "beginner",
  notes: [
    { beat: 0, midi: 40 }, // E2
    { beat: 1, midi: 45 }, // A2
    { beat: 2, midi: 50 }, // D3
    { beat: 3, midi: 55 }, // G3
    { beat: 4, midi: 59 }, // B3
    { beat: 5, midi: 64 }, // E4
  ]
};

// For backward compatibility
const song = defaultExercise.notes;

async function loadAvailableExercises() {
  try {
    const exerciseFiles = ['basic-strings.json', 'chromatic-scale.json', 'simple-melody.json', 'house-of-rising-sun.json'];
    availableExercises = [];

    // Add metronome-only option
    const metronomeOnlyExercise = {
      name: "Metronome Only",
      description: "Just metronome clicks, no tabs",
      bpm: 90,
      difficulty: "metronome",
      notes: [],
      fileName: "metronome-only"
    };
    availableExercises.push(metronomeOnlyExercise);

    for (const fileName of exerciseFiles) {
      try {
        const response = await fetch(`exercises/${fileName}?v=${Date.now()}`);
        if (response.ok) {
          const exercise = await response.json();
          exercise.fileName = fileName;
          availableExercises.push(exercise);
        } else {
          console.warn(`Failed to load exercise: ${fileName}`);
        }
      } catch (e) {
        console.warn(`Error loading exercise ${fileName}:`, e);
      }
    }

    // Use default exercise if no exercises were loaded (besides metronome-only)
    if (availableExercises.length === 1) { // Only metronome option
      availableExercises.push(defaultExercise);
    }

    populateExerciseDropdown();
    loadExercise(availableExercises[0]);
  } catch (e) {
    console.error('Failed to load exercises:', e);
    // Fallback to default exercise
    availableExercises = [defaultExercise];
    populateExerciseDropdown();
    loadExercise(defaultExercise);
  }
}

function populateExerciseDropdown() {
  const select = $("exercise");
  select.innerHTML = "";

  for (const exercise of availableExercises) {
    const option = document.createElement("option");
    option.value = exercise.fileName || "default";
    option.textContent = `${exercise.name} (${exercise.difficulty})`;
    select.appendChild(option);
  }
}

function loadExercise(exercise) {
  currentExercise = exercise;

  // Update the global song array for backward compatibility
  song.length = 0;
  song.push(...exercise.notes);

  // Update BPM if specified
  if (exercise.bpm) {
    setBpm(exercise.bpm);
  }

  // Reset the practice session
  if (state.practicing) {
    $("btnStop").click();
  }
  resetPractice();

  console.log(`Loaded exercise: ${exercise.name} (${exercise.notes.length} notes)`);
}

/**
 * -------------------------
 * Tuning knobs (MVP)
 * -------------------------
 */
const MIN_RMS = 0.003;       // gate for "is there sound?"
const STABLE_FRAMES = 2;     // require stable MIDI rounding for N frames
const CENTS_TOLERANCE = 40;  // pitch forgiveness
const COOLDOWN_SEC = 0.25;   // prevent double triggers on one note (reduced for slow tempos)
const DEFAULT_BPM = 90;
const BEATS_PER_BAR = 4;

/**
 * -------------------------
 * Guitar fretboard constants
 * -------------------------
 */
const TUNING = [40, 45, 50, 55, 59, 64]; // MIDI values for standard tuning (E-A-D-G-B-E)
const STRING_NAMES = ["E", "A", "D", "G", "B", "E"];
const STRING_POSITIONS = [345, 285, 225, 165, 105, 45]; // Y positions for each string
const LOOKAHEAD_BEATS = 4;   // notes appear 4 beats early
const HIT_ZONE_X = 60;       // X position of hit zone
let NOTE_TRAVEL_DISTANCE = 800; // will be calculated dynamically
const MAX_FRET = 12;         // maximum fret to consider

const $ = (id) => document.getElementById(id);

function calculateTravelDistance() {
  const fretboard = $("fretboard");
  if (fretboard) {
    const fretboardWidth = fretboard.offsetWidth;
    NOTE_TRAVEL_DISTANCE = fretboardWidth - HIT_ZONE_X - 40; // 40px padding from right edge
  }
}

function midiToName(midi) {
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const n = names[midi % 12];
  const oct = Math.floor(midi/12) - 1;
  return `${n}${oct}`;
}
function freqToMidi(freq) {
  return 69 + 12 * Math.log2(freq / 440);
}
function centsDiff(midiFloat, midiInt) {
  return (midiFloat - midiInt) * 100;
}
function secondsToBeats(seconds, bpm) {
  return (seconds * bpm) / 60;
}
function beatsToSeconds(beats, bpm) {
  return (beats * 60) / bpm;
}

/**
 * Convert MIDI note to guitar string and fret position
 * Returns { string: index, fret: number, y: pixel position } or null if unplayable
 */
function midiToFret(midiNote) {
  const candidates = [];

  // Check each string for possible fret positions
  for (let stringIdx = 0; stringIdx < TUNING.length; stringIdx++) {
    const openStringMidi = TUNING[stringIdx];
    const fret = midiNote - openStringMidi;

    // Must be a valid fret (0-MAX_FRET)
    if (fret >= 0 && fret <= MAX_FRET) {
      candidates.push({
        string: stringIdx,
        fret: fret,
        y: STRING_POSITIONS[stringIdx],
        stringName: STRING_NAMES[stringIdx]
      });
    }
  }

  if (candidates.length === 0) return null;

  // Prefer lower frets for easier playability
  // If multiple options, choose the one with lowest fret number
  candidates.sort((a, b) => a.fret - b.fret);
  return candidates[0];
}

/**
 * Timing window that adapts to tempo.
 * Wider at slow BPM so practice doesn't feel punishing.
 */
function timingWindowBeats(bpm) {
  // ~0.60 beats at 40 BPM, ~0.25 beats at 120 BPM, floor at 0.20
  return Math.max(0.20, Math.min(0.60, (120 / bpm) * 0.25));
}

/**
 * -------------------------
 * YIN pitch detector (monophonic)
 * -------------------------
 */
function yinPitch(buffer, sampleRate) {
  let rms = 0;
  for (let i = 0; i < buffer.length; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms / buffer.length);
  if (rms < MIN_RMS) return { freq: null, conf: 0, rms };

  const threshold = 0.12;
  const bufferSize = buffer.length;
  const maxTau = Math.floor(sampleRate / 50);
  const minTau = Math.floor(sampleRate / 1000);

  const d = new Float32Array(maxTau + 1);
  for (let tau = minTau; tau <= maxTau; tau++) {
    let sum = 0;
    const maxI = Math.max(0, bufferSize - tau);
    for (let i = 0; i < maxI; i++) {
      const delta = buffer[i] - buffer[i + tau];
      sum += delta * delta;
    }
    d[tau] = sum;
  }

  const cmndf = new Float32Array(maxTau + 1);
  cmndf[0] = 1;
  let runningSum = 0;
  for (let tau = 1; tau <= maxTau; tau++) {
    runningSum += d[tau];
    cmndf[tau] = runningSum === 0 ? 1 : d[tau] * tau / runningSum;
  }

  let tauEstimate = -1;
  for (let tau = minTau; tau <= maxTau; tau++) {
    if (tau < cmndf.length && cmndf[tau] < threshold) {
      while (tau + 1 <= maxTau && tau + 1 < cmndf.length && cmndf[tau + 1] < cmndf[tau]) tau++;
      tauEstimate = tau;
      break;
    }
  }
  if (tauEstimate === -1 || tauEstimate >= cmndf.length) return { freq: null, conf: 0, rms };

  // Parabolic interpolation
  const x0 = tauEstimate > 1 ? tauEstimate - 1 : tauEstimate;
  const x2 = tauEstimate + 1 <= maxTau && tauEstimate + 1 < cmndf.length ? tauEstimate + 1 : tauEstimate;

  const s0 = x0 < cmndf.length ? cmndf[x0] : 1;
  const s1 = tauEstimate < cmndf.length ? cmndf[tauEstimate] : 1;
  const s2 = x2 < cmndf.length ? cmndf[x2] : 1;

  const a = (s0 + s2 - 2 * s1) / 2;
  const b = (s2 - s0) / 2;
  const betterTau = (Math.abs(a) > 1e-10) ? (tauEstimate - b / (2 * a)) : tauEstimate;

  const freq = sampleRate / betterTau;
  const conf = Math.max(0, Math.min(1, 1 - cmndf[tauEstimate]));
  return { freq, conf, rms };
}

/**
 * Octave correction: if detector locks on a harmonic (octave up/down),
 * choose the octave variant closest to expected MIDI.
 */
function octaveCorrect(playedFreq, expectedMidi) {
  const playedMidi = freqToMidi(playedFreq);
  const candidates = [
    playedMidi,
    playedMidi - 12,
    playedMidi + 12,
  ];

  let best = candidates[0];
  let bestAbs = Math.abs(centsDiff(candidates[0], expectedMidi));
  for (const c of candidates) {
    const a = Math.abs(centsDiff(c, expectedMidi));
    if (a < bestAbs) { bestAbs = a; best = c; }
  }
  return { correctedMidi: best, centsOff: centsDiff(best, expectedMidi) };
}

/**
 * -------------------------
 * Visual notes management
 * -------------------------
 */
function clearVisualNotes() {
  for (const [noteId, noteData] of state.visualNotes) {
    if (noteData.element && noteData.element.parentNode) {
      noteData.element.remove();
    }
  }
  state.visualNotes.clear();
  state.nextNoteId = 0;
}

function createVisualNote(eventData, fretInfo) {
  const noteId = state.nextNoteId++;
  const fretboard = $("fretboard");

  const noteElement = document.createElement("div");
  noteElement.className = "fret-note";
  // Make open strings (fret 0) more distinguishable
  if (fretInfo.fret === 0) {
    noteElement.textContent = "O"; // Use "O" instead of "0" for open strings
    noteElement.style.fontSize = "20px"; // Slightly smaller for the "O"
    noteElement.classList.add("open-string");
  } else {
    noteElement.textContent = fretInfo.fret.toString();
  }

  // Calculate note duration for width
  const currentEventIndex = state.events.findIndex(e => e === eventData);
  let noteDuration = 1.0; // Default duration in beats

  if (currentEventIndex >= 0 && currentEventIndex < state.events.length - 1) {
    const nextEvent = state.events[currentEventIndex + 1];
    noteDuration = nextEvent.beat - eventData.beat;
  }

  // Convert duration to pixel width (scale it appropriately)
  const baseWidth = 80; // minimum width (matches min-width in CSS)
  const widthPerBeat = 100; // pixels per beat (increased for larger, more readable notes)
  const noteWidth = Math.max(baseWidth, noteDuration * widthPerBeat);

  noteElement.style.width = noteWidth + "px";

  // Start position (rightmost edge of fretboard) - using transform for better performance
  const startX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE;
  noteElement.style.left = "0px"; // Keep at origin for transform calculations
  noteElement.style.top = fretInfo.y + "px";
  noteElement.style.transform = `translate3d(${startX}px, -50%, 0)`;

  fretboard.appendChild(noteElement);

  const noteData = {
    element: noteElement,
    eventData: eventData,
    fretInfo: fretInfo,
    noteId: noteId,
    spawned: false,
    duration: noteDuration,
    feedbackShown: false
  };

  state.visualNotes.set(noteId, noteData);
  return noteData;
}

function updateVisualNotes(beatNow) {
  const fretboard = $("fretboard");
  const notesToRemove = [];

  // Spawn new notes that should be visible (exactly at LOOKAHEAD_BEATS before hit time)
  for (const event of state.events) {
    if (!event.visualNote && beatNow >= event.beat - LOOKAHEAD_BEATS && !event.judged) {
      const fretInfo = midiToFret(event.midi);
      if (fretInfo) {
        const noteData = createVisualNote(event, fretInfo);
        event.visualNote = noteData;
        noteData.spawned = true;
      }
    }
  }

  // Update positions of existing notes
  for (const [noteId, noteData] of state.visualNotes) {
    const event = noteData.eventData;
    const timeToHit = event.beat - beatNow;

    // Calculate position based on remaining time
    const progress = (LOOKAHEAD_BEATS - timeToHit) / LOOKAHEAD_BEATS;
    // Position so left edge touches hit zone when timeToHit = 0
    const currentX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE * (1 - progress);

    // Use transform for smoother animation and less motion blur
    noteData.element.style.transform = `translate3d(${currentX}px, -50%, 0)`;

    // Visual feedback is now handled immediately when notes are scored
    // No delayed feedback needed here

    // Update visual state based on hit/miss/skipped
    if (event.hit && !noteData.element.classList.contains("hit")) {
      noteData.element.classList.add("hit");
    }
    if (event.miss && !noteData.element.classList.contains("miss")) {
      noteData.element.classList.add("miss");
    }
    if (event.skipped && !noteData.element.classList.contains("skipped")) {
      noteData.element.classList.add("skipped");
    }

    // Remove notes that have passed the hit zone
    if (timeToHit < -1) { // 1 beat grace period after missing
      notesToRemove.push(noteId);
    }
  }

  // Clean up old notes
  for (const noteId of notesToRemove) {
    const noteData = state.visualNotes.get(noteId);
    if (noteData && noteData.element && noteData.element.parentNode) {
      noteData.element.remove();
    }
    state.visualNotes.delete(noteId);
  }
}

function updateScoreDisplay() {
  $("successCount").textContent = state.successCount;
  $("failCount").textContent = state.failCount;
  $("skippedCount").textContent = state.skippedCount;

  const total = state.successCount + state.failCount + state.skippedCount;
  const accuracy = total === 0 ? 0 : Math.round((state.successCount / total) * 100);
  $("accuracy").textContent = accuracy + "%";
}

function showHitZoneFeedback(isHit, isSkipped = false) {
  const hitZone = $("fretboard").querySelector(".hit-zone");

  // Remove any existing feedback classes
  hitZone.classList.remove("hit-feedback", "miss-feedback", "skip-feedback");

  // Add appropriate feedback class
  if (isHit) {
    hitZone.classList.add("hit-feedback");
  } else if (isSkipped) {
    hitZone.classList.add("skip-feedback");
  } else {
    hitZone.classList.add("miss-feedback");
  }

  // Remove feedback after animation
  setTimeout(() => {
    hitZone.classList.remove("hit-feedback", "miss-feedback", "skip-feedback");
  }, 300);
}

function addDebugEntry(entry) {
  const timestamp = new Date().toLocaleTimeString();
  const debugEntry = `[${timestamp}] ${entry}`;

  state.debugLog.push(debugEntry);

  // No limit - keep all entries
  updateDebugDisplay();
}

function updateDebugDisplay() {
  const debugLogElement = $("debugLog");
  if (debugLogElement) {
    debugLogElement.innerHTML = state.debugLog.join('<br>') || '<div style="opacity: 0.6;">No debug entries yet...</div>';
    debugLogElement.scrollTop = debugLogElement.scrollHeight;
  }
}

function clearDebugLog() {
  state.debugLog = [];
  updateDebugDisplay();
}

function copyDebugToClipboard() {
  const debugText = state.debugLog.join('\n');
  navigator.clipboard.writeText(debugText).then(() => {
    const btn = $("copyDebug");
    const originalText = btn.textContent;
    btn.textContent = "Copied!";
    setTimeout(() => {
      btn.textContent = originalText;
    }, 2000);
  }).catch(() => {
    alert("Copy failed. Debug text:\n\n" + debugText);
  });
}

function addPracticeHistoryEntry() {
  const timestamp = new Date().toLocaleString();
  const exerciseSelect = $("exercise");
  const exerciseName = exerciseSelect && exerciseSelect.selectedOptions.length > 0
    ? exerciseSelect.selectedOptions[0].text
    : "Unknown Exercise";

  const total = state.successCount + state.failCount + state.skippedCount;
  const accuracy = total === 0 ? 0 : Math.round((state.successCount / total) * 100);

  const historyEntry = {
    timestamp,
    exercise: exerciseName,
    bpm: state.bpm,
    hits: state.successCount,
    misses: state.failCount,
    skips: state.skippedCount,
    accuracy: accuracy,
    total: total
  };

  console.log('Adding practice history entry:', historyEntry);
  state.practiceHistory.push(historyEntry);
  console.log('Practice history now has', state.practiceHistory.length, 'entries');
  updatePracticeHistoryDisplay();
}

function updatePracticeHistoryDisplay() {
  const historyElement = $("practiceHistory");
  if (!historyElement) return;

  if (state.practiceHistory.length === 0) {
    historyElement.innerHTML = '<div style="opacity: 0.6; text-align: center; padding: 20px;">No practice sessions yet. Complete an exercise to see your history!</div>';
    return;
  }

  const historyHtml = state.practiceHistory.slice(-10).reverse().map(entry => {
    const accuracyColor = entry.accuracy >= 90 ? '#1a7f37' : entry.accuracy >= 70 ? '#ff9900' : '#b42318';
    return `
      <div style="border-bottom: 1px solid #ddd; padding: 8px 0; display: flex; justify-content: space-between; align-items: center;">
        <div>
          <div style="font-weight: bold; margin-bottom: 2px;">${entry.exercise}</div>
          <div style="font-size: 11px; opacity: 0.7;">${entry.timestamp}</div>
        </div>
        <div style="text-align: right;">
          <div style="font-weight: bold; color: ${accuracyColor};">${entry.accuracy}%</div>
          <div style="font-size: 11px;">${entry.bpm} BPM | ${entry.hits}‚úì ${entry.misses}‚úó ${entry.skips}‚äù</div>
        </div>
      </div>
    `;
  }).join('');

  historyElement.innerHTML = historyHtml;
  historyElement.scrollTop = 0; // Scroll to top to see latest
}

function clearPracticeHistory() {
  state.practiceHistory = [];
  updatePracticeHistoryDisplay();
}

function showFullScreenFeedback(isHit) {
  const overlay = $("feedbackOverlay");

  // Remove any existing feedback classes
  overlay.classList.remove("hit", "miss");

  // Add appropriate feedback class
  if (isHit) {
    overlay.classList.add("hit");
  } else {
    overlay.classList.add("miss");
  }

  // Remove feedback after animation
  setTimeout(() => {
    overlay.classList.remove("hit", "miss");
  }, 200);
}

/**
 * -------------------------
 * Rendering
 * -------------------------
 */
function renderNotes() {
  const root = $("notes");
  root.innerHTML = "";

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    const div = document.createElement("div");

    let cls = "note";
    if (i === state.nextIdx) cls += " next";
    if (ev.hit) cls += " hit";
    if (ev.miss) cls += " miss";
    if (ev.skipped) cls += " skipped";

    div.className = cls;
    div.innerHTML = `
      <div class="mono">${midiToName(ev.midi)}</div>
      <div class="t mono">beat=${ev.beat.toFixed(2)}</div>
    `;
    root.appendChild(div);
  }
}

/**
 * -------------------------
 * Matching logic
 * -------------------------
 */
function getNextUnhitIndex() {
  return state.events.findIndex(ev => !ev.hit && !ev.miss && !ev.skipped);
}

function judgeMisses(beatNow) {
  const win = timingWindowBeats(state.bpm);

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    if (!ev.judged && beatNow > ev.beat + win) {
      ev.judged = true;

      if (!ev.hit) {
        // Check if any input was attempted during this note's window
        const hadInputAttempt = state.inputAttemptedDuringWindow.has(i);

        if (hadInputAttempt) {
          // Wrong note was played
          ev.miss = true;
          state.failCount++;

          // Show miss feedback on hit zone
          showHitZoneFeedback(false, false);

          // Debug log for missed notes
          addDebugEntry(`‚ùå MISS: Expected ${midiToName(ev.midi)} at beat ${ev.beat.toFixed(2)}, but wrong note was played during timing window`);
        } else {
          // No input at all - note was skipped
          ev.skipped = true;
          state.skippedCount++;

          // Show skip feedback on hit zone
          showHitZoneFeedback(false, true);

          // Debug log for skipped notes
          addDebugEntry(`‚äù SKIP: Expected ${midiToName(ev.midi)} at beat ${ev.beat.toFixed(2)}, but no input detected during timing window`);
        }

        updateScoreDisplay();
      }

      // Clean up tracking for this event
      state.inputAttemptedDuringWindow.delete(i);
    }
  }

  const idx = getNextUnhitIndex();
  state.nextIdx = idx === -1 ? state.events.length - 1 : idx;
}

/**
 * Returns a verdict object for UI based on timing window matching
 */
function tryMatchPlayed(beatNow, playedFreq) {
  // Find nearest unhit note within timing window that's close enough in pitch
  const win = timingWindowBeats(state.bpm);
  let bestDb = Infinity;
  let idx = -1;

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    if (ev.hit) continue; // allow retries until missed
    const db = Math.abs(beatNow - ev.beat);
    if (db <= win && db < bestDb) {
      // Quick pitch check: reject notes that are more than 1 semitone away (even with octave correction)
      const { correctedMidi, centsOff } = octaveCorrect(playedFreq, ev.midi);
      const semitonesDiff = Math.abs(correctedMidi - ev.midi); // MIDI difference (1 MIDI = 1 semitone)

      if (semitonesDiff <= 1) { // Allow up to 1 semitone difference
        bestDb = db;
        idx = i;
      }
    }
  }

  if (idx === -1) return null;

  // Mark that input was attempted for this note (for skipped vs missed tracking)
  state.inputAttemptedDuringWindow.add(idx);

  const ev = state.events[idx];

  const { correctedMidi, centsOff } = octaveCorrect(playedFreq, ev.midi);
  const ok = Math.abs(centsOff) <= CENTS_TOLERANCE;

  const timingBeats = beatNow - ev.beat;

  if (ok) {
    ev.hit = true;
    ev.judged = true;
  }

  return {
    ok,
    expected: ev.midi,
    detected: correctedMidi,
    centsOff,
    timingBeats,
    expectedBeat: ev.beat
  };
}

/**
 * -------------------------
 * Metronome (click on beat)
 * -------------------------
 * Uses AudioContext oscillator for a short "tick".
 * Downbeat is higher frequency.
 */
function metroTick(isDownbeat) {
  if (!state.audioCtx) return;
  const ctx = state.audioCtx;

  // Duck detection briefly after we emit the tick (prevents mic hearing the click)
  state.ignoreUntil = Math.max(state.ignoreUntil, ctx.currentTime + 0.12);

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";
  osc.frequency.value = isDownbeat ? 1200 : 880;

  const t = ctx.currentTime;
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(0.20, t + 0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start(t);
  osc.stop(t + 0.07);
}


/**
 * -------------------------
 * App state
 * -------------------------
 */
const state = {
  audioCtx: null,
  analyser: null,
  micStream: null,
  rafId: null,

  practicing: false,

  bpm: DEFAULT_BPM,

  // time model:
  // beatNow = secondsToBeats(audioCtx.currentTime - startTime, bpm)
  startTime: 0,

  // metronome scheduler:
  lastMetroBeat: -1,
  nextMetroTime: 0,

  // detection stability:
  stableCount: 0,
  lastMidiRounded: null,
  lastTriggerAt: 0,

  // Track input attempts for skipped vs missed detection
  inputAttemptedDuringWindow: new Set(), // Set of event indices that had input attempts

  // song events:
  events: song.map(e => ({...e, hit:false, miss:false, skipped:false, judged:false, visualNote:null })),
  nextIdx: 0,

  // visual notes on fretboard
  visualNotes: new Map(),  // noteId -> visual note element
  nextNoteId: 0,

  // score tracking
  successCount: 0,
  failCount: 0,
  skippedCount: 0,

  ignoreUntil: 0,          // audioCtx time until which we ignore detection (ducking)
  lastRms: 0,              // optional: simple onset gating baseline
  // auto-stop tracking for exercise completion
  exerciseCompleted: false,
  exerciseEndBeat: null,
  autoStopScheduled: false,
  // metronome-only time limit (10 minutes)
  metronomeStartTime: null,
  metronomeTimeLimit: 10 * 60, // 10 minutes in seconds

  // Enhanced debug logging
  debugLog: [],

  // Practice history tracking
  practiceHistory: []
};

function resetPractice() {
  state.practicing = false;
  state.startTime = 0;
  state.lastMetroBeat = -1;
  state.nextMetroTime = 0;

  state.stableCount = 0;
  state.lastMidiRounded = null;
  state.lastTriggerAt = 0;

  state.events = song.map(e => ({...e, hit:false, miss:false, skipped:false, judged:false, visualNote:null }));
  state.nextIdx = 0;

  // Clear input tracking
  state.inputAttemptedDuringWindow.clear();

  // Reset auto-stop tracking
  state.exerciseCompleted = false;
  state.exerciseEndBeat = null;
  state.autoStopScheduled = false;
  state.metronomeStartTime = null;

  // Clear visual notes
  clearVisualNotes();

  // Reset score counters
  state.successCount = 0;
  state.failCount = 0;
  state.skippedCount = 0;
  updateScoreDisplay();

  $("now").textContent = "‚Äî";
  $("lastNote").textContent = "‚Äî";
  $("lastNoteMeta").textContent = "‚Äî";
  $("status").textContent = "ready";
  renderNotes();
}

function currentBeat(nowAudioTime) {
  const elapsed = nowAudioTime - state.startTime;
  return secondsToBeats(elapsed, state.bpm);
}

/**
 * -------------------------
 * Main loop
 * -------------------------
 */
function loop() {
  if (!state.practicing) return;

  const now = state.audioCtx.currentTime;
  const beatNow = currentBeat(now);

  // Always update visual elements first (prevents animation stuttering)
  // Update visual notes animation
  updateVisualNotes(beatNow);

  // Skip audio processing briefly after metronome tick (prevents self-triggering)
  // but continue with visual updates
  const skipAudioProcessing = now < state.ignoreUntil;

  // Count-in handling (beatNow < 0 means we're counting in)
  if (beatNow < 0) {
    $("now").textContent = `count-in‚Ä¶ beat=${beatNow.toFixed(2)} @ ${state.bpm} BPM`;
  } else {
    $("now").textContent = `beat=${beatNow.toFixed(3)} @ ${state.bpm} BPM`;
  }

  // Metronome tick (including count-in if enabled) with precise timing
  if ($("metroOn").checked) {
    if (now >= state.nextMetroTime && state.nextMetroTime > 0) {
      const currentBeatInt = Math.floor(beatNow);

      // Determine downbeat within bars (handles negative beats too)
      const barPos = ((currentBeatInt % BEATS_PER_BAR) + BEATS_PER_BAR) % BEATS_PER_BAR;
      const isDownbeat = (barPos === 0);
      metroTick(isDownbeat);

      // Schedule next tick precisely
      const beatDuration = beatsToSeconds(1, state.bpm);
      state.nextMetroTime += beatDuration;

      // Prevent accumulating drift by resetting if we get too far behind
      if (state.nextMetroTime < now - beatDuration) {
        state.nextMetroTime = now + beatDuration;
      }
    }
  }

  // Audio processing (skip during metronome ducking period)
  let freq = null, conf = 0, rms = 0, onset = false;
  let debugReason = "";
  if (!skipAudioProcessing) {
    // Read mic samples
    const buf = new Float32Array(state.analyser.fftSize);
    state.analyser.getFloatTimeDomainData(buf);

    const pitchResult = yinPitch(buf, state.audioCtx.sampleRate);
    freq = pitchResult.freq;
    conf = pitchResult.conf;
    rms = pitchResult.rms;

    // crude onset: require a jump in level vs previous frame (helps ignore steady speech/background)
    // Simplified for guitar: just need RMS above minimum OR a relative jump
    onset = rms > 0.004 || rms > state.lastRms * 1.2;
    state.lastRms = 0.9 * state.lastRms + 0.1 * rms; // smooth baseline
  }

  // UI: input level / debug
  $("level").value = Math.min(1, rms * 20);
  $("levelText").textContent =
    `rms=${rms.toFixed(4)} conf=${conf.toFixed(2)} freq=${freq ? freq.toFixed(1) : "‚Äî"}`;

  // Visual notes already updated above (to prevent stuttering)

  // If we're still in count-in, do not judge notes (but still show detected pitch)
  if (beatNow < 0) {
    state.rafId = requestAnimationFrame(loop);
    return;
  }

  // Pitch processing and note matching (skip during metronome ducking)
  let midiFloat = null;
  let midiRounded = null;

  if (!skipAudioProcessing && freq) {
    midiFloat = freqToMidi(freq);
    midiRounded = Math.round(midiFloat);

    // Stability gate
    if (midiRounded !== null) {
      if (state.lastMidiRounded === midiRounded) state.stableCount++;
      else { state.lastMidiRounded = midiRounded; state.stableCount = 1; }
    } else {
      state.lastMidiRounded = null;
      state.stableCount = 0;
    }

    // Trigger gate - make cooldown tempo-aware
    const beatDurationSec = 60 / state.bpm;
    const adaptiveCooldown = Math.min(COOLDOWN_SEC, beatDurationSec * 0.3); // Max 30% of beat duration
    const canTrigger = (now - state.lastTriggerAt) > adaptiveCooldown;

    // Debug: Check why detection might fail
    if (freq !== null && rms > MIN_RMS) {
      const reasons = [];
      if (conf < 0.65) reasons.push(`conf=${conf.toFixed(2)}<0.65`);
      if (!onset) {
        const minThreshold = 0.004;
        const relativeThreshold = state.lastRms * 1.2;
        reasons.push(`no onset (rms=${rms.toFixed(4)} ‚â§ ${minThreshold} AND ‚â§ ${relativeThreshold.toFixed(4)})`);
      }
      if (midiFloat === null) reasons.push("no MIDI");
      if (state.stableCount < STABLE_FRAMES) reasons.push(`unstable=${state.stableCount}/${STABLE_FRAMES}`);
      if (!canTrigger) reasons.push(`cooldown (${adaptiveCooldown.toFixed(2)}s)`);

      if (reasons.length > 0) {
        debugReason = `üîç DETECTED ${freq.toFixed(1)}Hz (${midiToName(Math.round(freqToMidi(freq)))}) but BLOCKED: ${reasons.join(", ")}`;
      }
    } else if (rms > 0.001) {
      debugReason = `üîá SIGNAL TOO WEAK: rms=${rms.toFixed(4)} (need >${MIN_RMS}) or no frequency detected`;
    }

    // Don't trigger new matches after exercise is completed (avoid feedback spam from sustained strings)
    const shouldProcessDetection = !state.exerciseCompleted && conf >= 0.65 && onset && midiFloat !== null && state.stableCount >= STABLE_FRAMES && canTrigger;

    if (shouldProcessDetection) {
      state.lastTriggerAt = now;

      // Match against tab
      const verdict = tryMatchPlayed(beatNow, freq);

      // UI: show detected note
      $("lastNote").textContent = midiToName(midiRounded);
      $("lastNote").classList.add("flash");

      if (verdict) {
        const detectedName = midiToName(Math.round(verdict.detected));
        const expectedName = midiToName(verdict.expected);

        $("lastNoteMeta").textContent =
          `expected=${expectedName} detected‚âà${detectedName} ` +
          `cents=${verdict.centsOff.toFixed(1)} ` +
          `Œîbeat=${verdict.timingBeats.toFixed(2)} (win‚âà${timingWindowBeats(state.bpm).toFixed(2)})`;

        $("lastNote").style.outlineColor = verdict.ok ? "#1a7f37" : "#b42318";
        $("status").textContent = verdict.ok ? "‚úì correct" : "‚úó wrong";

        // Enhanced debug logging
        const rawMidiDetected = freqToMidi(freq);
        const rawNoteName = midiToName(Math.round(rawMidiDetected));
        const debugInfo = [
          `üéµ MATCH: ${verdict.ok ? "‚úì HIT" : "‚úó MISS"}`,
          `Expected: ${expectedName} (MIDI ${verdict.expected})`,
          `Raw: ${rawNoteName} (${freq.toFixed(1)}Hz) ‚Üí Corrected: ${detectedName} (MIDI ${Math.round(verdict.detected)})`,
          `Conf: ${conf.toFixed(2)}`,
          `Timing: beat ${beatNow.toFixed(2)}, expected ${verdict.expectedBeat.toFixed(2)} (Œî${verdict.timingBeats.toFixed(2)})`,
          `Tolerance: ¬±${(timingWindowBeats(state.bpm).toFixed(2))} beats, ¬±${CENTS_TOLERANCE} cents`,
          `Cents Off: ${verdict.centsOff.toFixed(1)} (${Math.abs(verdict.centsOff) <= CENTS_TOLERANCE ? "within tolerance" : "outside tolerance"})`
        ].join(" | ");

        addDebugEntry(debugInfo);

        // Update score counters
        if (verdict.ok) {
          state.successCount++;
        } else {
          state.failCount++;
        }
        updateScoreDisplay();

        // Show immediate feedback
        showFullScreenFeedback(verdict.ok);
        showHitZoneFeedback(verdict.ok);
      } else {
        $("lastNoteMeta").textContent = `no note within timing window`;
        $("lastNote").style.outlineColor = "#999";
        $("status").textContent = "no match";

        // Log cases where no note was matched
        addDebugEntry(`üîç NO MATCH: Detected ${midiToName(midiRounded)} (${freq.toFixed(1)}Hz, conf ${conf.toFixed(2)}) at beat ${beatNow.toFixed(2)} but no expected note within timing window`);
      }

      setTimeout(() => $("lastNote").classList.remove("flash"), 200);
    } else if (debugReason && !state.exerciseCompleted) {
      // Log why detection failed (but don't spam - only during timing windows and before exercise completion)
      const hasActiveNote = state.events.some(ev => !ev.judged && Math.abs(beatNow - ev.beat) <= timingWindowBeats(state.bpm));
      if (hasActiveNote) {
        addDebugEntry(debugReason);
      }
    }

    // Update progression
    judgeMisses(beatNow);
    renderNotes();
  } else {
    // Audio processing skipped during metronome ducking, but still update misses
    judgeMisses(beatNow);
    renderNotes();
  }

  // Check if exercise is completed and schedule auto-stop (only for exercises with notes)
  if (!state.exerciseCompleted && state.events.length > 0) {
    const allNotesJudged = state.events.every(ev => ev.judged);
    if (allNotesJudged) {
      state.exerciseCompleted = true;
      // Find the last note's beat to calculate when to stop
      const lastNoteBeat = Math.max(...state.events.map(ev => ev.beat));
      state.exerciseEndBeat = lastNoteBeat + 4; // Stop 4 beats after last note
      $("status").textContent = "exercise complete, stopping in 4 beats...";

      // Log exercise completion and stop feedback spam
      addDebugEntry("üéâ EXERCISE COMPLETE: All notes judged. Stopping detection feedback to prevent sustained string spam.");
    }
  }

  // Auto-stop after exercise completion + 4 beats
  if (state.exerciseCompleted && !state.autoStopScheduled && beatNow >= state.exerciseEndBeat) {
    state.autoStopScheduled = true;
    $("btnStop").click(); // Trigger the stop button
    return; // Exit the loop
  }

  // 10-minute time limit for metronome-only mode (when no notes)
  if (state.events.length === 0 && state.metronomeStartTime) {
    const elapsedTime = now - state.metronomeStartTime;
    if (elapsedTime >= state.metronomeTimeLimit) {
      $("status").textContent = "10-minute metronome session completed";
      $("btnStop").click(); // Trigger the stop button
      return; // Exit the loop
    } else {
      // Show remaining time for metronome-only mode
      const remainingMinutes = Math.ceil((state.metronomeTimeLimit - elapsedTime) / 60);
      if (remainingMinutes <= 1 || Math.floor(elapsedTime) % 60 === 0) {
        $("status").textContent = `metronome (${remainingMinutes} min remaining)`;
      }
    }
  }

  state.rafId = requestAnimationFrame(loop);
}

/**
 * -------------------------
 * Controls
 * -------------------------
 */
function setBpm(bpm) {
  bpm = Math.max(40, Math.min(200, Number(bpm)));
  state.bpm = bpm;
  $("bpm").value = bpm;
  $("bpmNum").value = bpm;
}

$("bpm").addEventListener("input", (e) => setBpm(e.target.value));
$("bpmNum").addEventListener("change", (e) => setBpm(e.target.value));

$("exercise").addEventListener("change", (e) => {
  const selectedFileName = e.target.value;
  const exercise = availableExercises.find(ex => (ex.fileName || "default") === selectedFileName);
  if (exercise) {
    loadExercise(exercise);
  }
});

$("btnMic").addEventListener("click", async () => {
  try {
    if (state.audioCtx || state.micStream) {
      console.log("Microphone already initialized");
      return;
    }

    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Request mic
    state.micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
      }
    });

    const src = state.audioCtx.createMediaStreamSource(state.micStream);

    // Bigger window helps low notes (E2)
    state.analyser = state.audioCtx.createAnalyser();
    state.analyser.fftSize = 8192;

    src.connect(state.analyser);

    $("micStatus").textContent = "Enabled ‚úì (listening)";
    $("status").textContent = "mic ready";
    $("btnStart").disabled = false;
    $("btnMic").textContent = "Mic Enabled ‚úì";
    $("btnMic").disabled = true;
  } catch (e) {
    let errorMessage = "Unknown error";
    let statusMessage = "mic error";

    if (e.name === "NotAllowedError") {
      errorMessage = "Microphone permission denied. Please allow microphone access and try again.";
      statusMessage = "permission denied";
    } else if (e.name === "NotFoundError") {
      errorMessage = "No microphone found. Please connect a microphone and try again.";
      statusMessage = "no microphone";
    } else if (e.name === "NotReadableError") {
      errorMessage = "Microphone in use by another application. Please close other apps and try again.";
      statusMessage = "mic busy";
    } else if (e.name === "OverconstrainedError") {
      errorMessage = "Microphone doesn't support required settings. Trying with default settings...";
      statusMessage = "retrying...";
      // Try again with less strict constraints
      try {
        state.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const src = state.audioCtx.createMediaStreamSource(state.micStream);
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = 8192;
        src.connect(state.analyser);

        $("micStatus").textContent = "Enabled ‚úì (basic settings)";
        $("status").textContent = "mic ready";
        $("btnStart").disabled = false;
        $("btnMic").textContent = "Mic Enabled ‚úì";
        $("btnMic").disabled = true;
        return;
      } catch (retryError) {
        errorMessage = `Microphone failed: ${retryError?.message || retryError}`;
        statusMessage = "mic failed";
      }
    } else {
      errorMessage = `Microphone error: ${e?.message || e}`;
    }

    $("micStatus").textContent = errorMessage;
    $("status").textContent = statusMessage;
    console.error("Microphone initialization failed:", e);

    // Reset state on error
    state.audioCtx = null;
    state.micStream = null;
    state.analyser = null;
  }
});

$("btnStart").addEventListener("click", async () => {
  if (!state.audioCtx) return;

  // Ensure AudioContext is running (some browsers need a user gesture)
  if (state.audioCtx.state === "suspended") {
    await state.audioCtx.resume();
  }

  resetPractice();

  state.practicing = true;

  // Set metronome start time for time limit tracking
  state.metronomeStartTime = state.audioCtx.currentTime;

  const useCountIn = $("countInOn").checked;
  const countInBeats = useCountIn ? BEATS_PER_BAR : 0;

  // Set start time in the future so beatNow starts negative (count-in)
  state.startTime = state.audioCtx.currentTime + beatsToSeconds(countInBeats, state.bpm);

  // Schedule first metronome tick precisely
  const beatDuration = beatsToSeconds(1, state.bpm);
  state.nextMetroTime = state.audioCtx.currentTime + beatDuration;

  $("btnStop").disabled = false;
  $("btnStart").disabled = true;
  $("status").textContent = useCountIn ? "count-in‚Ä¶" : "running";

  state.rafId = requestAnimationFrame(loop);

  // Log exercise start with expected notes sequence
  const exerciseNotes = state.events.map((ev, i) =>
    `${i + 1}: ${midiToName(ev.midi)} (beat ${ev.beat.toFixed(1)})`
  ).join(", ");
  addDebugEntry(`üéº EXERCISE START: ${exerciseNotes}`);
});

$("btnStop").addEventListener("click", () => {
  // Save practice history before resetting stats (only if there was actual practice)
  const hadPractice = state.successCount > 0 || state.failCount > 0 || state.skippedCount > 0;
  console.log(`Stop pressed - practicing: ${state.practicing}, hadPractice: ${hadPractice}, stats: ${state.successCount}‚úì ${state.failCount}‚úó ${state.skippedCount}‚äù`);

  if (state.practicing && hadPractice) {
    addPracticeHistoryEntry();
    addDebugEntry(`üíæ SAVED PRACTICE: ${state.successCount}‚úì ${state.failCount}‚úó ${state.skippedCount}‚äù`);
  } else {
    addDebugEntry(`‚ùå NO SAVE: practicing=${state.practicing}, stats=${state.successCount}‚úì ${state.failCount}‚úó ${state.skippedCount}‚äù`);
  }

  state.practicing = false;

  // Cancel animation frame
  if (state.rafId) {
    cancelAnimationFrame(state.rafId);
    state.rafId = null;
  }

  // Reset practice state
  resetPractice();

  // Clean up visual notes
  clearVisualNotes();

  // Clean up audio resources (but keep mic enabled for quick restart)
  if (state.audioCtx && state.audioCtx.state !== "closed") {
    // Don't close the AudioContext to avoid reinitialization overhead
    // Just stop any scheduled audio
    state.ignoreUntil = 0;
    state.nextMetroTime = 0;
  }

  // Update UI
  $("btnStop").disabled = true;
  $("btnStart").disabled = false;
  $("status").textContent = "stopped";

  // Clear detection displays
  $("lastNote").textContent = "‚Äî";
  $("lastNoteMeta").textContent = "‚Äî";
  $("now").textContent = "‚Äî";
  if ($("lastNote").classList.contains("flash")) {
    $("lastNote").classList.remove("flash");
  }
});

// Initial render
setBpm(DEFAULT_BPM);
renderNotes();
updateScoreDisplay();
$("status").textContent = "ready";

// Calculate proper travel distance based on fretboard width
calculateTravelDistance();

// Load available exercises
loadAvailableExercises();

// Debug button event listeners
$("clearDebug").addEventListener("click", clearDebugLog);
$("copyDebug").addEventListener("click", copyDebugToClipboard);

// Practice history button event listener
$("clearHistory").addEventListener("click", clearPracticeHistory);

// Recalculate on window resize
window.addEventListener('resize', () => {
  calculateTravelDistance();
});

// MusicXML Upload functionality
function setupMusicXMLUpload() {
  const uploadSection = $("uploadSection");
  const fileInput = $("musicxmlFile");
  const uploadStatus = $("uploadStatus");

  // Handle file input change
  fileInput.addEventListener("change", handleFileUpload);

  // Handle drag and drop
  uploadSection.addEventListener("dragover", (e) => {
    e.preventDefault();
    uploadSection.classList.add("dragover");
  });

  uploadSection.addEventListener("dragleave", (e) => {
    e.preventDefault();
    uploadSection.classList.remove("dragover");
  });

  uploadSection.addEventListener("drop", (e) => {
    e.preventDefault();
    uploadSection.classList.remove("dragover");

    const files = e.dataTransfer.files;
    if (files.length > 0) {
      handleFile(files[0]);
    }
  });

  function handleFileUpload(e) {
    const file = e.target.files[0];
    if (file) {
      handleFile(file);
    }
  }

  function handleFile(file) {
    // Validate file type
    const validExtensions = ['.mxl', '.xml', '.musicxml'];
    const fileExtension = file.name.toLowerCase().substring(file.name.lastIndexOf('.'));

    if (!validExtensions.includes(fileExtension)) {
      showUploadStatus("Please select a MusicXML file (.mxl, .xml, or .musicxml)", "error");
      return;
    }

    // Validate file size (max 5MB)
    if (file.size > 5 * 1024 * 1024) {
      showUploadStatus("File is too large. Please select a file smaller than 5MB.", "error");
      return;
    }

    showUploadStatus("Reading file...", "");

    // Check if it's a compressed .mxl file
    if (fileExtension === '.mxl') {
      // Read as binary for ZIP extraction
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          extractMXLFile(e.target.result, file.name);
        } catch (error) {
          console.error("Error reading MXL file:", error);
          showUploadStatus("Error reading MXL file. Please try again.", "error");
        }
      };

      reader.onerror = function() {
        showUploadStatus("Error reading MXL file. Please try again.", "error");
      };

      reader.readAsArrayBuffer(file);
    } else {
      // Read as text for XML files
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const xmlContent = e.target.result;
          processMusicXMLFile(xmlContent, file.name);
        } catch (error) {
          console.error("Error reading file:", error);
          showUploadStatus("Error reading file. Please try again.", "error");
        }
      };

      reader.onerror = function() {
        showUploadStatus("Error reading file. Please try again.", "error");
      };

      reader.readAsText(file);
    }
  }

  function extractMXLFile(arrayBuffer, fileName) {
    try {
      showUploadStatus("Extracting MXL file...", "");

      // Use JSZip to properly extract the MXL file
      JSZip.loadAsync(arrayBuffer).then(function(zip) {
        // Look for score.xml in the ZIP
        const scoreFile = zip.file("score.xml");

        if (!scoreFile) {
          showUploadStatus("Could not find score.xml in MXL file.", "error");
          return;
        }

        // Extract the score.xml content
        scoreFile.async("text").then(function(xmlContent) {
          processMusicXMLFile(xmlContent, fileName);
        }).catch(function(error) {
          console.error("Error reading score.xml:", error);
          showUploadStatus("Error reading score.xml from MXL file.", "error");
        });

      }).catch(function(error) {
        console.error("Error extracting MXL file:", error);
        showUploadStatus("Invalid MXL file format. Please check the file.", "error");
      });

    } catch (error) {
      console.error("Error processing MXL file:", error);
      showUploadStatus("Error processing MXL file. Please try a different file.", "error");
    }
  }

  function processMusicXMLFile(xmlContent, fileName) {
    try {
      // Basic validation - check if it's valid XML and contains MusicXML elements
      const parser = new DOMParser();
      const xmlDoc = parser.parseFromString(xmlContent, "text/xml");

      // Check for XML parsing errors
      const parseError = xmlDoc.getElementsByTagName("parsererror");
      if (parseError.length > 0) {
        showUploadStatus("Invalid XML file. Please check the file format.", "error");
        return;
      }

      // Check for MusicXML root elements
      const scorePartwise = xmlDoc.getElementsByTagName("score-partwise")[0];
      const scoreTimewise = xmlDoc.getElementsByTagName("score-timewise")[0];

      if (!scorePartwise && !scoreTimewise) {
        showUploadStatus("This doesn't appear to be a valid MusicXML file.", "error");
        return;
      }

      // Successfully parsed MusicXML
      showUploadStatus(`Successfully loaded: ${fileName}`, "success");

      // Store the XML content for later conversion
      window.uploadedMusicXML = {
        content: xmlContent,
        fileName: fileName,
        xmlDoc: xmlDoc
      };

      console.log("MusicXML file loaded successfully:", fileName);

      // Convert MusicXML to exercise format
      const exercise = convertMusicXMLToExercise(xmlDoc, fileName);
      if (exercise) {
        addExerciseToList(exercise);
        showUploadStatus(`Successfully converted: ${fileName} (${exercise.notes.length} notes)`, "success");
      }

    } catch (error) {
      console.error("Error processing MusicXML:", error);
      showUploadStatus("Error processing MusicXML file.", "error");
    }
  }

  function showUploadStatus(message, type) {
    uploadStatus.textContent = message;
    uploadStatus.className = `upload-status ${type}`;
  }

  function convertMusicXMLToExercise(xmlDoc, fileName) {
    try {
      // Extract basic info
      const scorePartwise = xmlDoc.getElementsByTagName("score-partwise")[0];
      const scoreTimewise = xmlDoc.getElementsByTagName("score-timewise")[0];
      const rootElement = scorePartwise || scoreTimewise;

      if (!rootElement) {
        showUploadStatus("Invalid MusicXML structure", "error");
        return null;
      }

      // Get title from various possible sources (in order of preference)
      let title = fileName.replace(/\.[^/.]+$/, ""); // Default to filename

      // First check credit-words (often contains the actual title)
      const creditWords = xmlDoc.getElementsByTagName("credit-words");
      for (let i = 0; i < creditWords.length; i++) {
        const creditText = creditWords[i].textContent?.trim();
        if (creditText &&
            creditText !== "Subtitle" &&
            creditText !== "Composer / arranger" &&
            creditText !== "Title" &&
            creditText.length > 3) {
          title = creditText;
          break;
        }
      }

      // Fallback to work-title or movement-title if no good credit-words found
      if (!title || title === fileName.replace(/\.[^/.]+$/, "")) {
        const workElement = xmlDoc.getElementsByTagName("work-title")[0];
        const movementTitle = xmlDoc.getElementsByTagName("movement-title")[0];
        const workTitle = workElement?.textContent?.trim();
        const moveTitle = movementTitle?.textContent?.trim();

        if (workTitle && workTitle !== "Untitled score" && workTitle !== "") {
          title = workTitle;
        } else if (moveTitle && moveTitle !== "") {
          title = moveTitle;
        }
      }

      // Get tempo (default to 120 if not found)
      let bpm = 120;
      const tempoElements = xmlDoc.getElementsByTagName("per-minute");
      if (tempoElements.length > 0) {
        bpm = parseInt(tempoElements[0].textContent) || 120;
      }

      // Extract notes
      const notes = [];
      let currentBeat = 0;

      // Get all measures
      const measures = xmlDoc.getElementsByTagName("measure");

      for (let measureIndex = 0; measureIndex < measures.length; measureIndex++) {
        const measure = measures[measureIndex];
        const noteElements = measure.getElementsByTagName("note");

        for (let noteIndex = 0; noteIndex < noteElements.length; noteIndex++) {
          const noteElement = noteElements[noteIndex];

          // Skip rests
          if (noteElement.getElementsByTagName("rest").length > 0) {
            // Still need to advance timing for rests
            const duration = getDuration(noteElement);
            currentBeat += duration;
            continue;
          }

          // Skip chord tones (keep only the first note of chords)
          if (noteElement.getElementsByTagName("chord").length > 0) {
            continue;
          }

          // Get pitch
          const pitch = noteElement.getElementsByTagName("pitch")[0];
          if (!pitch) continue;

          const step = pitch.getElementsByTagName("step")[0]?.textContent;
          const alter = pitch.getElementsByTagName("alter")[0]?.textContent;
          const octave = pitch.getElementsByTagName("octave")[0]?.textContent;

          if (!step || !octave) continue;

          // Convert to MIDI note number
          const midiNote = pitchToMIDI(step, alter ? parseInt(alter) : 0, parseInt(octave));

          // Filter to guitar range (MIDI 40-84, E2 to C6)
          if (midiNote >= 40 && midiNote <= 84) {
            notes.push({
              beat: Math.round(currentBeat * 4) / 4, // Round to nearest quarter beat
              midi: midiNote
            });
          }

          // Advance timing
          const duration = getDuration(noteElement);
          currentBeat += duration;
        }
      }

      // Create exercise object
      const exercise = {
        name: title,
        description: `Converted from ${fileName}`,
        bpm: Math.min(Math.max(bpm, 40), 200), // Clamp between 40-200
        difficulty: notes.length > 30 ? "intermediate" : "beginner",
        notes: notes,
        isUploaded: true // Mark as uploaded to distinguish from built-in exercises
      };

      console.log("Converted exercise:", exercise);
      return exercise;

    } catch (error) {
      console.error("Error converting MusicXML to exercise:", error);
      showUploadStatus("Error converting MusicXML to exercise format", "error");
      return null;
    }
  }

  function getDuration(noteElement) {
    // Get duration in quarter notes (simplified)
    const durationElement = noteElement.getElementsByTagName("duration")[0];
    const typeElement = noteElement.getElementsByTagName("type")[0];

    if (durationElement) {
      // Duration is in divisions of a quarter note
      const duration = parseInt(durationElement.textContent);
      const divisions = 1; // Simplified - should get from attributes
      return duration / divisions / 4; // Convert to beats
    }

    if (typeElement) {
      const type = typeElement.textContent;
      const durations = {
        'whole': 4,
        'half': 2,
        'quarter': 1,
        'eighth': 0.5,
        '16th': 0.25,
        '32nd': 0.125
      };
      return durations[type] || 1;
    }

    return 1; // Default to quarter note
  }

  function pitchToMIDI(step, alter, octave) {
    // Convert note name to MIDI number
    const noteValues = { 'C': 0, 'D': 2, 'E': 4, 'F': 5, 'G': 7, 'A': 9, 'B': 11 };
    const baseNote = noteValues[step];
    return (octave + 1) * 12 + baseNote + (alter || 0);
  }

  function addExerciseToList(exercise) {
    // Add to available exercises array
    availableExercises.push(exercise);

    // Update the dropdown
    populateExerciseDropdown();

    // Automatically select the new exercise
    const exerciseSelect = $("exercise");
    exerciseSelect.value = exercise.name;

    // Load the exercise
    loadExercise(exercise);
  }
}

// Initialize upload functionality
setupMusicXMLUpload();
</script>
</body>
</html>
