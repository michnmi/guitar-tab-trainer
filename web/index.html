<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Tab Trainer (Monophonic)</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
    h1 { margin: 0 0 12px 0; }
    button, input, select { font-size: 16px; }
    button { padding: 10px 14px; }
    .row { display:flex; gap:16px; flex-wrap: wrap; align-items:center; }
    .panel { border:1px solid #ddd; border-radius:12px; padding:16px; min-width: 320px; }
    .big { font-size: 20px; font-weight: 650; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, monospace; }
    label { display:block; font-size: 12px; opacity: 0.75; margin-bottom: 6px; }

    .notes { display:flex; gap:10px; flex-wrap: wrap; }
    .note {
      border:1px solid #ddd; border-radius:10px; padding:10px 12px; min-width:84px;
      text-align:center;
    }
    .note .t { font-size: 12px; opacity: 0.7; margin-top: 6px;}
    .note.hit { border-color: #1a7f37; }
    .note.miss { border-color: #b42318; }
    .note.skipped { border-color: #ff9900; opacity: 0.7; }
    .note.next { border-width: 2px; }

    /* Guitar fretboard styles */
    .fretboard {
      position: relative;
      width: 100%;
      height: 420px;
      background: linear-gradient(to bottom, #2a2a2a 0%, #1a1a1a 100%);
      border-radius: 8px;
      overflow: hidden;
      margin-top: 12px;
    }

    .string {
      position: absolute;
      left: 0;
      right: 0;
      height: 2px;
      background: #888;
      border-radius: 1px;
    }

    .string.e-high { top: 45px; }
    .string.b { top: 105px; }
    .string.g { top: 165px; }
    .string.d { top: 225px; }
    .string.a { top: 285px; }
    .string.e-low { top: 345px; }

    .hit-zone {
      position: absolute;
      left: 60px;
      top: 0;
      bottom: 0;
      width: 4px;
      background: #00ff88;
      box-shadow: 0 0 10px #00ff88;
      z-index: 10;
      transition: all 0.2s ease;
    }

    .hit-zone.hit-feedback {
      background: #00ff00;
      box-shadow: 0 0 30px #00ff00, 0 0 60px #00ff00;
      width: 8px;
      transform: scaleY(1.2);
    }

    .hit-zone.miss-feedback {
      background: #ff4444;
      box-shadow: 0 0 30px #ff4444, 0 0 60px #ff4444;
      width: 8px;
      transform: scaleY(1.2);
    }

    .hit-zone.skip-feedback {
      background: #ff9900;
      box-shadow: 0 0 20px #ff9900, 0 0 40px #ff9900;
      width: 6px;
      transform: scaleY(1.1);
    }

    /* Full-screen feedback overlay */
    .feedback-overlay {
      position: fixed;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      z-index: 1000;
      pointer-events: none;
      opacity: 0;
      transition: opacity 0.1s ease;
    }

    .feedback-overlay.hit {
      background: radial-gradient(circle, rgba(26, 127, 55, 0.3) 0%, rgba(26, 127, 55, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    .feedback-overlay.miss {
      background: radial-gradient(circle, rgba(180, 35, 24, 0.3) 0%, rgba(180, 35, 24, 0.1) 50%, transparent 100%);
      opacity: 1;
    }

    /* Enhanced fret note feedback */
    .fret-note.hit {
      background: #1a7f37;
      box-shadow: 0 0 25px #1a7f37, 0 0 50px #1a7f37;
      transform: translateY(-50%) scaleY(1.3);
      border-color: #00ff00;
      border-width: 3px;
    }

    .fret-note.miss {
      background: #b42318;
      box-shadow: 0 0 25px #b42318, 0 0 50px #b42318;
      transform: translateY(-50%) scaleY(1.3);
      border-color: #ff4444;
      border-width: 3px;
    }

    .fret-note.skipped {
      background: #ff9900;
      box-shadow: 0 0 15px #ff9900, 0 0 30px #ff9900;
      transform: translateY(-50%) scaleY(1.1);
      border-color: #ffaa33;
      border-width: 2px;
      opacity: 0.7;
    }

    .fret-note {
      position: absolute;
      min-width: 80px;
      height: 56px;
      border-radius: 16px;
      border: 5px solid #000;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 32px;
      font-weight: 900;
      font-family: ui-monospace, SFMono-Regular, Menlo, monospace;
      color: #000;
      background: linear-gradient(145deg, #ffffff, #f0f0f0);
      transform: translateY(-50%);
      transition: none;
      z-index: 5;
      box-sizing: border-box;
      text-shadow:
        1px 1px 2px rgba(255,255,255,0.9),
        -1px -1px 2px rgba(255,255,255,0.9),
        2px 2px 4px rgba(0,0,0,0.3);
      box-shadow:
        0 0 0 2px #333,
        0 6px 20px rgba(0,0,0,0.4),
        inset 0 1px 0 rgba(255,255,255,0.8);
      will-change: transform;
      /* Anti-motion-blur techniques */
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      text-rendering: geometricPrecision;
      backface-visibility: hidden;
      -webkit-backface-visibility: hidden;
      transform-style: preserve-3d;
      /* Force hardware acceleration for smoother movement */
      -webkit-transform: translateZ(0) translateY(-50%);
      transform: translateZ(0) translateY(-50%);
      /* Prevent subpixel rendering issues and ensure crisp text */
      -webkit-transform: translate3d(0, -50%, 0);
      transform: translate3d(0, -50%, 0);
      /* Snap to pixel boundaries for crisp rendering */
      image-rendering: crisp-edges;
      image-rendering: -moz-crisp-edges;
      image-rendering: -webkit-optimize-contrast;
      /* Ensure text stays sharp during animation */
      -webkit-font-feature-settings: "liga" 0;
      font-feature-settings: "liga" 0;
    }

    .fret-note.open-string {
      background: linear-gradient(145deg, #9370db, #6a5acd);
      color: #fff;
      border-color: #4b0082;
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .fret-note.hit {
      background: linear-gradient(145deg, #22c55e, #16a34a);
      color: #fff;
      border-color: #15803d;
      box-shadow:
        0 0 0 2px #15803d,
        0 0 25px #22c55e,
        0 6px 20px rgba(0,0,0,0.4);
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .fret-note.miss {
      background: linear-gradient(145deg, #ef4444, #dc2626);
      color: #fff;
      border-color: #b91c1c;
      box-shadow:
        0 0 0 2px #b91c1c,
        0 0 25px #ef4444,
        0 6px 20px rgba(0,0,0,0.4);
      text-shadow:
        1px 1px 2px rgba(0,0,0,0.8),
        -1px -1px 2px rgba(0,0,0,0.5);
    }

    .string-label {
      position: absolute;
      left: 10px;
      transform: translateY(-50%);
      font-size: 14px;
      font-weight: bold;
      color: #fff;
      text-shadow: 0 0 3px #000;
    }

    .flash {
      outline: 3px solid #999;
      border-radius: 10px;
      padding: 4px 8px;
      display: inline-block;
    }

    progress { width: 100%; height: 18px; }
    .hint { opacity: 0.75; font-size: 13px; margin-top: 10px; line-height: 1.35; }
  </style>
</head>

<body>
  <h1>Tab Trainer (Single Notes)</h1>

  <!-- Technical Controls at Top -->
  <div class="panel" style="margin-bottom: 20px;">
    <div class="row">
      <button id="btnMic">Enable Mic</button>
      <button id="btnStart" disabled>Start</button>
      <button id="btnStop" disabled>Stop</button>
      <div class="mono" id="status" style="opacity:0.8;">—</div>
    </div>

    <div class="row" style="margin-top:16px; gap:32px; flex-wrap:wrap;">
      <!-- Exercise Controls -->
      <div style="min-width:200px;">
        <div style="margin-bottom:10px;">
          <label for="exercise">Exercise</label>
          <select id="exercise">
            <option value="">Loading exercises...</option>
          </select>
        </div>
      </div>

      <!-- Tempo Controls -->
      <div style="min-width:220px;">
        <label for="bpm">BPM</label>
        <div class="row" style="gap:10px;">
          <input id="bpm" type="range" min="40" max="200" value="90" />
          <input id="bpmNum" type="number" min="40" max="200" value="90" style="width:90px;" />
        </div>
        <div style="margin-top:10px;">
          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="metroOn" type="checkbox" checked />
            Metronome
          </label>
          <label class="mono" style="display:flex; gap:10px; align-items:center; font-size:14px; opacity:1;">
            <input id="countInOn" type="checkbox" checked />
            4-beat count-in
          </label>
        </div>
      </div>

      <!-- Microphone Status -->
      <div style="min-width:180px;">
        <div id="micStatus" class="mono" style="margin-bottom:6px;">Not enabled</div>
        <progress id="level" value="0" max="1" style="width:100%; margin-bottom:4px;"></progress>
        <div id="levelText" class="mono" style="font-size:12px;">rms=—</div>
      </div>

      <!-- Detection Status -->
      <div style="min-width:160px;">
        <div style="margin-bottom:4px;">
          <strong>Last Note:</strong>
          <div id="lastNote" class="mono" style="font-size:18px;">—</div>
        </div>
        <div id="now" class="mono" style="font-size:12px;">—</div>
      </div>
    </div>
  </div>

  <!-- Main Fretboard Display -->
  <div class="panel" style="width: 100%; margin-bottom: 12px;">
    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 16px;">
      <div class="big">Guitar Fretboard</div>
      <div id="scoreDisplay" style="display: flex; gap: 20px; font-size: 18px; font-weight: bold;">
        <div style="color: #1a7f37;">✓ <span id="successCount">0</span></div>
        <div style="color: #b42318;">✗ <span id="failCount">0</span></div>
        <div style="color: #ff9900;">⊝ <span id="skippedCount">0</span></div>
        <div style="color: #666;">Accuracy: <span id="accuracy">0%</span></div>
      </div>
    </div>

    <div class="fretboard" id="fretboard">
      <!-- String lines -->
      <div class="string e-high"></div>
      <div class="string b"></div>
      <div class="string g"></div>
      <div class="string d"></div>
      <div class="string a"></div>
      <div class="string e-low"></div>

      <!-- String labels -->
      <div class="string-label" style="top: 45px;">E</div>
      <div class="string-label" style="top: 105px;">B</div>
      <div class="string-label" style="top: 165px;">G</div>
      <div class="string-label" style="top: 225px;">D</div>
      <div class="string-label" style="top: 285px;">A</div>
      <div class="string-label" style="top: 345px;">E</div>

      <!-- Hit zone -->
      <div class="hit-zone"></div>
    </div>

    <!-- Fallback notes display for debugging (hidden by default) -->
    <div id="notes" class="notes" style="margin-top:12px; display: none;"></div>

    <div class="hint">
      Notes move from right to left. Play them when the left edge reaches the green line.
    </div>
  </div>

  <!-- Debug Info (Collapsible) -->
  <details class="panel" style="margin-top: 12px;">
    <summary style="cursor: pointer; font-weight: bold;">Debug Information</summary>
    <div style="margin-top: 12px;">
      <div id="lastNoteMeta" class="mono" style="opacity:0.8; font-size:12px; margin-bottom:8px;">—</div>
      <div class="hint">
        Debug tip: pluck one string cleanly (open A or D) and let it ring.
        Low E can be harder to detect.
      </div>
    </div>
  </details>

  <!-- Full-screen feedback overlay -->
  <div id="feedbackOverlay" class="feedback-overlay"></div>

<script>
/**
 * -------------------------
 * Exercise management
 * -------------------------
 */
let availableExercises = [];
let currentExercise = null;

// Default fallback exercise (same as original hardcoded)
const defaultExercise = {
  name: "Basic Strings",
  description: "Learn the open strings: E-A-D-G-B-E",
  bpm: 90,
  difficulty: "beginner",
  notes: [
    { beat: 0, midi: 40 }, // E2
    { beat: 1, midi: 45 }, // A2
    { beat: 2, midi: 50 }, // D3
    { beat: 3, midi: 55 }, // G3
    { beat: 4, midi: 59 }, // B3
    { beat: 5, midi: 64 }, // E4
  ]
};

// For backward compatibility
const song = defaultExercise.notes;

async function loadAvailableExercises() {
  try {
    const exerciseFiles = ['basic-strings.json', 'chromatic-scale.json', 'simple-melody.json', 'house-of-rising-sun.json'];
    availableExercises = [];

    // Add metronome-only option
    const metronomeOnlyExercise = {
      name: "Metronome Only",
      description: "Just metronome clicks, no tabs",
      bpm: 90,
      difficulty: "metronome",
      notes: [],
      fileName: "metronome-only"
    };
    availableExercises.push(metronomeOnlyExercise);

    for (const fileName of exerciseFiles) {
      try {
        const response = await fetch(`exercises/${fileName}`);
        if (response.ok) {
          const exercise = await response.json();
          exercise.fileName = fileName;
          availableExercises.push(exercise);
        } else {
          console.warn(`Failed to load exercise: ${fileName}`);
        }
      } catch (e) {
        console.warn(`Error loading exercise ${fileName}:`, e);
      }
    }

    // Use default exercise if no exercises were loaded (besides metronome-only)
    if (availableExercises.length === 1) { // Only metronome option
      availableExercises.push(defaultExercise);
    }

    populateExerciseDropdown();
    loadExercise(availableExercises[0]);
  } catch (e) {
    console.error('Failed to load exercises:', e);
    // Fallback to default exercise
    availableExercises = [defaultExercise];
    populateExerciseDropdown();
    loadExercise(defaultExercise);
  }
}

function populateExerciseDropdown() {
  const select = $("exercise");
  select.innerHTML = "";

  for (const exercise of availableExercises) {
    const option = document.createElement("option");
    option.value = exercise.fileName || "default";
    option.textContent = `${exercise.name} (${exercise.difficulty})`;
    select.appendChild(option);
  }
}

function loadExercise(exercise) {
  currentExercise = exercise;

  // Update the global song array for backward compatibility
  song.length = 0;
  song.push(...exercise.notes);

  // Update BPM if specified
  if (exercise.bpm) {
    setBpm(exercise.bpm);
  }

  // Reset the practice session
  if (state.practicing) {
    $("btnStop").click();
  }
  resetPractice();

  console.log(`Loaded exercise: ${exercise.name} (${exercise.notes.length} notes)`);
}

/**
 * -------------------------
 * Tuning knobs (MVP)
 * -------------------------
 */
const MIN_RMS = 0.003;       // gate for "is there sound?"
const STABLE_FRAMES = 2;     // require stable MIDI rounding for N frames
const CENTS_TOLERANCE = 40;  // pitch forgiveness
const COOLDOWN_SEC = 0.22;   // prevent double triggers on one note
const DEFAULT_BPM = 90;
const BEATS_PER_BAR = 4;

/**
 * -------------------------
 * Guitar fretboard constants
 * -------------------------
 */
const TUNING = [40, 45, 50, 55, 59, 64]; // MIDI values for standard tuning (E-A-D-G-B-E)
const STRING_NAMES = ["E", "A", "D", "G", "B", "E"];
const STRING_POSITIONS = [345, 285, 225, 165, 105, 45]; // Y positions for each string
const LOOKAHEAD_BEATS = 4;   // notes appear 4 beats early
const HIT_ZONE_X = 60;       // X position of hit zone
let NOTE_TRAVEL_DISTANCE = 800; // will be calculated dynamically
const MAX_FRET = 12;         // maximum fret to consider

const $ = (id) => document.getElementById(id);

function calculateTravelDistance() {
  const fretboard = $("fretboard");
  if (fretboard) {
    const fretboardWidth = fretboard.offsetWidth;
    NOTE_TRAVEL_DISTANCE = fretboardWidth - HIT_ZONE_X - 40; // 40px padding from right edge
  }
}

function midiToName(midi) {
  const names = ["C","C#","D","D#","E","F","F#","G","G#","A","A#","B"];
  const n = names[midi % 12];
  const oct = Math.floor(midi/12) - 1;
  return `${n}${oct}`;
}
function freqToMidi(freq) {
  return 69 + 12 * Math.log2(freq / 440);
}
function centsDiff(midiFloat, midiInt) {
  return (midiFloat - midiInt) * 100;
}
function secondsToBeats(seconds, bpm) {
  return (seconds * bpm) / 60;
}
function beatsToSeconds(beats, bpm) {
  return (beats * 60) / bpm;
}

/**
 * Convert MIDI note to guitar string and fret position
 * Returns { string: index, fret: number, y: pixel position } or null if unplayable
 */
function midiToFret(midiNote) {
  const candidates = [];

  // Check each string for possible fret positions
  for (let stringIdx = 0; stringIdx < TUNING.length; stringIdx++) {
    const openStringMidi = TUNING[stringIdx];
    const fret = midiNote - openStringMidi;

    // Must be a valid fret (0-MAX_FRET)
    if (fret >= 0 && fret <= MAX_FRET) {
      candidates.push({
        string: stringIdx,
        fret: fret,
        y: STRING_POSITIONS[stringIdx],
        stringName: STRING_NAMES[stringIdx]
      });
    }
  }

  if (candidates.length === 0) return null;

  // Prefer lower frets for easier playability
  // If multiple options, choose the one with lowest fret number
  candidates.sort((a, b) => a.fret - b.fret);
  return candidates[0];
}

/**
 * Timing window that adapts to tempo.
 * Wider at slow BPM so practice doesn't feel punishing.
 */
function timingWindowBeats(bpm) {
  // ~0.60 beats at 40 BPM, ~0.25 beats at 120 BPM, floor at 0.20
  return Math.max(0.20, Math.min(0.60, (120 / bpm) * 0.25));
}

/**
 * -------------------------
 * YIN pitch detector (monophonic)
 * -------------------------
 */
function yinPitch(buffer, sampleRate) {
  let rms = 0;
  for (let i = 0; i < buffer.length; i++) rms += buffer[i] * buffer[i];
  rms = Math.sqrt(rms / buffer.length);
  if (rms < MIN_RMS) return { freq: null, conf: 0, rms };

  const threshold = 0.12;
  const bufferSize = buffer.length;
  const maxTau = Math.floor(sampleRate / 50);
  const minTau = Math.floor(sampleRate / 1000);

  const d = new Float32Array(maxTau + 1);
  for (let tau = minTau; tau <= maxTau; tau++) {
    let sum = 0;
    const maxI = Math.max(0, bufferSize - tau);
    for (let i = 0; i < maxI; i++) {
      const delta = buffer[i] - buffer[i + tau];
      sum += delta * delta;
    }
    d[tau] = sum;
  }

  const cmndf = new Float32Array(maxTau + 1);
  cmndf[0] = 1;
  let runningSum = 0;
  for (let tau = 1; tau <= maxTau; tau++) {
    runningSum += d[tau];
    cmndf[tau] = runningSum === 0 ? 1 : d[tau] * tau / runningSum;
  }

  let tauEstimate = -1;
  for (let tau = minTau; tau <= maxTau; tau++) {
    if (tau < cmndf.length && cmndf[tau] < threshold) {
      while (tau + 1 <= maxTau && tau + 1 < cmndf.length && cmndf[tau + 1] < cmndf[tau]) tau++;
      tauEstimate = tau;
      break;
    }
  }
  if (tauEstimate === -1 || tauEstimate >= cmndf.length) return { freq: null, conf: 0, rms };

  // Parabolic interpolation
  const x0 = tauEstimate > 1 ? tauEstimate - 1 : tauEstimate;
  const x2 = tauEstimate + 1 <= maxTau && tauEstimate + 1 < cmndf.length ? tauEstimate + 1 : tauEstimate;

  const s0 = x0 < cmndf.length ? cmndf[x0] : 1;
  const s1 = tauEstimate < cmndf.length ? cmndf[tauEstimate] : 1;
  const s2 = x2 < cmndf.length ? cmndf[x2] : 1;

  const a = (s0 + s2 - 2 * s1) / 2;
  const b = (s2 - s0) / 2;
  const betterTau = (Math.abs(a) > 1e-10) ? (tauEstimate - b / (2 * a)) : tauEstimate;

  const freq = sampleRate / betterTau;
  const conf = Math.max(0, Math.min(1, 1 - cmndf[tauEstimate]));
  return { freq, conf, rms };
}

/**
 * Octave correction: if detector locks on a harmonic (octave up/down),
 * choose the octave variant closest to expected MIDI.
 */
function octaveCorrect(playedFreq, expectedMidi) {
  const playedMidi = freqToMidi(playedFreq);
  const candidates = [
    playedMidi,
    playedMidi - 12,
    playedMidi + 12,
  ];

  let best = candidates[0];
  let bestAbs = Math.abs(centsDiff(candidates[0], expectedMidi));
  for (const c of candidates) {
    const a = Math.abs(centsDiff(c, expectedMidi));
    if (a < bestAbs) { bestAbs = a; best = c; }
  }
  return { correctedMidi: best, centsOff: centsDiff(best, expectedMidi) };
}

/**
 * -------------------------
 * Visual notes management
 * -------------------------
 */
function clearVisualNotes() {
  for (const [noteId, noteData] of state.visualNotes) {
    if (noteData.element && noteData.element.parentNode) {
      noteData.element.remove();
    }
  }
  state.visualNotes.clear();
  state.nextNoteId = 0;
}

function createVisualNote(eventData, fretInfo) {
  const noteId = state.nextNoteId++;
  const fretboard = $("fretboard");

  const noteElement = document.createElement("div");
  noteElement.className = "fret-note";
  // Make open strings (fret 0) more distinguishable
  if (fretInfo.fret === 0) {
    noteElement.textContent = "O"; // Use "O" instead of "0" for open strings
    noteElement.style.fontSize = "20px"; // Slightly smaller for the "O"
    noteElement.classList.add("open-string");
  } else {
    noteElement.textContent = fretInfo.fret.toString();
  }

  // Calculate note duration for width
  const currentEventIndex = state.events.findIndex(e => e === eventData);
  let noteDuration = 1.0; // Default duration in beats

  if (currentEventIndex >= 0 && currentEventIndex < state.events.length - 1) {
    const nextEvent = state.events[currentEventIndex + 1];
    noteDuration = nextEvent.beat - eventData.beat;
  }

  // Convert duration to pixel width (scale it appropriately)
  const baseWidth = 80; // minimum width (matches min-width in CSS)
  const widthPerBeat = 100; // pixels per beat (increased for larger, more readable notes)
  const noteWidth = Math.max(baseWidth, noteDuration * widthPerBeat);

  noteElement.style.width = noteWidth + "px";

  // Start position (rightmost edge of fretboard) - using transform for better performance
  const startX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE;
  noteElement.style.left = "0px"; // Keep at origin for transform calculations
  noteElement.style.top = fretInfo.y + "px";
  noteElement.style.transform = `translate3d(${startX}px, -50%, 0)`;

  fretboard.appendChild(noteElement);

  const noteData = {
    element: noteElement,
    eventData: eventData,
    fretInfo: fretInfo,
    noteId: noteId,
    spawned: false,
    duration: noteDuration,
    feedbackShown: false
  };

  state.visualNotes.set(noteId, noteData);
  return noteData;
}

function updateVisualNotes(beatNow) {
  const fretboard = $("fretboard");
  const notesToRemove = [];

  // Spawn new notes that should be visible (exactly at LOOKAHEAD_BEATS before hit time)
  for (const event of state.events) {
    if (!event.visualNote && beatNow >= event.beat - LOOKAHEAD_BEATS && !event.judged) {
      const fretInfo = midiToFret(event.midi);
      if (fretInfo) {
        const noteData = createVisualNote(event, fretInfo);
        event.visualNote = noteData;
        noteData.spawned = true;
      }
    }
  }

  // Update positions of existing notes
  for (const [noteId, noteData] of state.visualNotes) {
    const event = noteData.eventData;
    const timeToHit = event.beat - beatNow;

    // Calculate position based on remaining time
    const progress = (LOOKAHEAD_BEATS - timeToHit) / LOOKAHEAD_BEATS;
    // Position so left edge touches hit zone when timeToHit = 0
    const currentX = HIT_ZONE_X + NOTE_TRAVEL_DISTANCE * (1 - progress);

    // Use transform for smoother animation and less motion blur
    noteData.element.style.transform = `translate3d(${currentX}px, -50%, 0)`;

    // Check if right edge has passed the hit zone for visual feedback
    const noteWidth = parseFloat(noteData.element.style.width) || 80;
    const rightEdgeX = currentX + noteWidth;
    const hasPassedHitZone = rightEdgeX <= HIT_ZONE_X;

    // Trigger visual feedback when right edge passes hit zone
    if (hasPassedHitZone && !noteData.feedbackShown && event.judged) {
      noteData.feedbackShown = true;

      if (event.hit) {
        showHitZoneFeedback(true);
      } else if (event.skipped) {
        showHitZoneFeedback(false, true);
      } else if (event.miss) {
        showHitZoneFeedback(false, false);
      }
    }

    // Update visual state based on hit/miss/skipped
    if (event.hit && !noteData.element.classList.contains("hit")) {
      noteData.element.classList.add("hit");
    }
    if (event.miss && !noteData.element.classList.contains("miss")) {
      noteData.element.classList.add("miss");
    }
    if (event.skipped && !noteData.element.classList.contains("skipped")) {
      noteData.element.classList.add("skipped");
    }

    // Remove notes that have passed the hit zone
    if (timeToHit < -1) { // 1 beat grace period after missing
      notesToRemove.push(noteId);
    }
  }

  // Clean up old notes
  for (const noteId of notesToRemove) {
    const noteData = state.visualNotes.get(noteId);
    if (noteData && noteData.element && noteData.element.parentNode) {
      noteData.element.remove();
    }
    state.visualNotes.delete(noteId);
  }
}

function updateScoreDisplay() {
  $("successCount").textContent = state.successCount;
  $("failCount").textContent = state.failCount;
  $("skippedCount").textContent = state.skippedCount;

  const total = state.successCount + state.failCount + state.skippedCount;
  const accuracy = total === 0 ? 0 : Math.round((state.successCount / total) * 100);
  $("accuracy").textContent = accuracy + "%";
}

function showHitZoneFeedback(isHit, isSkipped = false) {
  const hitZone = $("fretboard").querySelector(".hit-zone");

  // Remove any existing feedback classes
  hitZone.classList.remove("hit-feedback", "miss-feedback", "skip-feedback");

  // Add appropriate feedback class
  if (isHit) {
    hitZone.classList.add("hit-feedback");
  } else if (isSkipped) {
    hitZone.classList.add("skip-feedback");
  } else {
    hitZone.classList.add("miss-feedback");
  }

  // Remove feedback after animation
  setTimeout(() => {
    hitZone.classList.remove("hit-feedback", "miss-feedback", "skip-feedback");
  }, 300);
}

function showFullScreenFeedback(isHit) {
  const overlay = $("feedbackOverlay");

  // Remove any existing feedback classes
  overlay.classList.remove("hit", "miss");

  // Add appropriate feedback class
  if (isHit) {
    overlay.classList.add("hit");
  } else {
    overlay.classList.add("miss");
  }

  // Remove feedback after animation
  setTimeout(() => {
    overlay.classList.remove("hit", "miss");
  }, 200);
}

/**
 * -------------------------
 * Rendering
 * -------------------------
 */
function renderNotes() {
  const root = $("notes");
  root.innerHTML = "";

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    const div = document.createElement("div");

    let cls = "note";
    if (i === state.nextIdx) cls += " next";
    if (ev.hit) cls += " hit";
    if (ev.miss) cls += " miss";
    if (ev.skipped) cls += " skipped";

    div.className = cls;
    div.innerHTML = `
      <div class="mono">${midiToName(ev.midi)}</div>
      <div class="t mono">beat=${ev.beat.toFixed(2)}</div>
    `;
    root.appendChild(div);
  }
}

/**
 * -------------------------
 * Matching logic
 * -------------------------
 */
function getNextUnhitIndex() {
  return state.events.findIndex(ev => !ev.hit && !ev.miss && !ev.skipped);
}

function judgeMisses(beatNow) {
  const win = timingWindowBeats(state.bpm);

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    if (!ev.judged && beatNow > ev.beat + win) {
      ev.judged = true;

      if (!ev.hit) {
        // Check if any input was attempted during this note's window
        const hadInputAttempt = state.inputAttemptedDuringWindow.has(i);

        if (hadInputAttempt) {
          // Wrong note was played
          ev.miss = true;
          state.failCount++;
        } else {
          // No input at all - note was skipped
          ev.skipped = true;
          state.skippedCount++;
        }

        updateScoreDisplay();
      }

      // Clean up tracking for this event
      state.inputAttemptedDuringWindow.delete(i);
    }
  }

  const idx = getNextUnhitIndex();
  state.nextIdx = idx === -1 ? state.events.length - 1 : idx;
}

/**
 * Returns a verdict object for UI based on timing window matching
 */
function tryMatchPlayed(beatNow, playedFreq) {
  // Find nearest unhit note within timing window
  const win = timingWindowBeats(state.bpm);
  let bestDb = Infinity;
  let idx = -1;

  for (let i = 0; i < state.events.length; i++) {
    const ev = state.events[i];
    if (ev.hit) continue; // allow retries until missed
    const db = Math.abs(beatNow - ev.beat);
    if (db <= win && db < bestDb) {
      bestDb = db;
      idx = i;
    }
  }

  if (idx === -1) return null;

  // Mark that input was attempted for this note (for skipped vs missed tracking)
  state.inputAttemptedDuringWindow.add(idx);

  const ev = state.events[idx];

  const { correctedMidi, centsOff } = octaveCorrect(playedFreq, ev.midi);
  const ok = Math.abs(centsOff) <= CENTS_TOLERANCE;

  const timingBeats = beatNow - ev.beat;

  if (ok) {
    ev.hit = true;
    ev.judged = true;
  }

  return {
    ok,
    expected: ev.midi,
    detected: correctedMidi,
    centsOff,
    timingBeats,
    expectedBeat: ev.beat
  };
}

/**
 * -------------------------
 * Metronome (click on beat)
 * -------------------------
 * Uses AudioContext oscillator for a short "tick".
 * Downbeat is higher frequency.
 */
function metroTick(isDownbeat) {
  if (!state.audioCtx) return;
  const ctx = state.audioCtx;

  // Duck detection briefly after we emit the tick (prevents mic hearing the click)
  state.ignoreUntil = Math.max(state.ignoreUntil, ctx.currentTime + 0.12);

  const osc = ctx.createOscillator();
  const gain = ctx.createGain();

  osc.type = "sine";
  osc.frequency.value = isDownbeat ? 1200 : 880;

  const t = ctx.currentTime;
  gain.gain.setValueAtTime(0.0001, t);
  gain.gain.exponentialRampToValueAtTime(0.20, t + 0.005);
  gain.gain.exponentialRampToValueAtTime(0.0001, t + 0.06);

  osc.connect(gain);
  gain.connect(ctx.destination);

  osc.start(t);
  osc.stop(t + 0.07);
}


/**
 * -------------------------
 * App state
 * -------------------------
 */
const state = {
  audioCtx: null,
  analyser: null,
  micStream: null,
  rafId: null,

  practicing: false,

  bpm: DEFAULT_BPM,

  // time model:
  // beatNow = secondsToBeats(audioCtx.currentTime - startTime, bpm)
  startTime: 0,

  // metronome scheduler:
  lastMetroBeat: -1,
  nextMetroTime: 0,

  // detection stability:
  stableCount: 0,
  lastMidiRounded: null,
  lastTriggerAt: 0,

  // Track input attempts for skipped vs missed detection
  inputAttemptedDuringWindow: new Set(), // Set of event indices that had input attempts

  // song events:
  events: song.map(e => ({...e, hit:false, miss:false, skipped:false, judged:false, visualNote:null })),
  nextIdx: 0,

  // visual notes on fretboard
  visualNotes: new Map(),  // noteId -> visual note element
  nextNoteId: 0,

  // score tracking
  successCount: 0,
  failCount: 0,
  skippedCount: 0,

  ignoreUntil: 0,          // audioCtx time until which we ignore detection (ducking)
  lastRms: 0,              // optional: simple onset gating baseline
  // auto-stop tracking for exercise completion
  exerciseCompleted: false,
  exerciseEndBeat: null,
  autoStopScheduled: false,
  // metronome-only time limit (10 minutes)
  metronomeStartTime: null,
  metronomeTimeLimit: 10 * 60 // 10 minutes in seconds
};

function resetPractice() {
  state.practicing = false;
  state.startTime = 0;
  state.lastMetroBeat = -1;
  state.nextMetroTime = 0;

  state.stableCount = 0;
  state.lastMidiRounded = null;
  state.lastTriggerAt = 0;

  state.events = song.map(e => ({...e, hit:false, miss:false, skipped:false, judged:false, visualNote:null }));
  state.nextIdx = 0;

  // Clear input tracking
  state.inputAttemptedDuringWindow.clear();

  // Reset auto-stop tracking
  state.exerciseCompleted = false;
  state.exerciseEndBeat = null;
  state.autoStopScheduled = false;
  state.metronomeStartTime = null;

  // Clear visual notes
  clearVisualNotes();

  // Reset score counters
  state.successCount = 0;
  state.failCount = 0;
  state.skippedCount = 0;
  updateScoreDisplay();

  $("now").textContent = "—";
  $("lastNote").textContent = "—";
  $("lastNoteMeta").textContent = "—";
  $("status").textContent = "ready";
  renderNotes();
}

function currentBeat(nowAudioTime) {
  const elapsed = nowAudioTime - state.startTime;
  return secondsToBeats(elapsed, state.bpm);
}

/**
 * -------------------------
 * Main loop
 * -------------------------
 */
function loop() {
  if (!state.practicing) return;

  const now = state.audioCtx.currentTime;
  const beatNow = currentBeat(now);

  // Always update visual elements first (prevents animation stuttering)
  // Update visual notes animation
  updateVisualNotes(beatNow);

  // Skip audio processing briefly after metronome tick (prevents self-triggering)
  // but continue with visual updates
  const skipAudioProcessing = now < state.ignoreUntil;

  // Count-in handling (beatNow < 0 means we're counting in)
  if (beatNow < 0) {
    $("now").textContent = `count-in… beat=${beatNow.toFixed(2)} @ ${state.bpm} BPM`;
  } else {
    $("now").textContent = `beat=${beatNow.toFixed(3)} @ ${state.bpm} BPM`;
  }

  // Metronome tick (including count-in if enabled) with precise timing
  if ($("metroOn").checked) {
    if (now >= state.nextMetroTime && state.nextMetroTime > 0) {
      const currentBeatInt = Math.floor(beatNow);

      // Determine downbeat within bars (handles negative beats too)
      const barPos = ((currentBeatInt % BEATS_PER_BAR) + BEATS_PER_BAR) % BEATS_PER_BAR;
      const isDownbeat = (barPos === 0);
      metroTick(isDownbeat);

      // Schedule next tick precisely
      const beatDuration = beatsToSeconds(1, state.bpm);
      state.nextMetroTime += beatDuration;

      // Prevent accumulating drift by resetting if we get too far behind
      if (state.nextMetroTime < now - beatDuration) {
        state.nextMetroTime = now + beatDuration;
      }
    }
  }

  // Audio processing (skip during metronome ducking period)
  let freq = null, conf = 0, rms = 0, onset = false;
  if (!skipAudioProcessing) {
    // Read mic samples
    const buf = new Float32Array(state.analyser.fftSize);
    state.analyser.getFloatTimeDomainData(buf);

    const pitchResult = yinPitch(buf, state.audioCtx.sampleRate);
    freq = pitchResult.freq;
    conf = pitchResult.conf;
    rms = pitchResult.rms;

    // crude onset: require a jump in level vs previous frame (helps ignore steady speech/background)
    onset = rms > Math.max(0.01, state.lastRms * 1.8);
    state.lastRms = 0.9 * state.lastRms + 0.1 * rms; // smooth baseline
  }

  // UI: input level / debug
  $("level").value = Math.min(1, rms * 20);
  $("levelText").textContent =
    `rms=${rms.toFixed(4)} conf=${conf.toFixed(2)} freq=${freq ? freq.toFixed(1) : "—"}`;

  // Visual notes already updated above (to prevent stuttering)

  // If we're still in count-in, do not judge notes (but still show detected pitch)
  if (beatNow < 0) {
    state.rafId = requestAnimationFrame(loop);
    return;
  }

  // Pitch processing and note matching (skip during metronome ducking)
  let midiFloat = null;
  let midiRounded = null;

  if (!skipAudioProcessing && freq) {
    midiFloat = freqToMidi(freq);
    midiRounded = Math.round(midiFloat);

    // Stability gate
    if (midiRounded !== null) {
      if (state.lastMidiRounded === midiRounded) state.stableCount++;
      else { state.lastMidiRounded = midiRounded; state.stableCount = 1; }
    } else {
      state.lastMidiRounded = null;
      state.stableCount = 0;
    }

    // Trigger gate
    const canTrigger = (now - state.lastTriggerAt) > COOLDOWN_SEC;

    if (conf >= 0.65 && onset && midiFloat !== null && state.stableCount >= STABLE_FRAMES && canTrigger) {
      state.lastTriggerAt = now;

      // Match against tab
      const verdict = tryMatchPlayed(beatNow, freq);

      // UI: show detected note
      $("lastNote").textContent = midiToName(midiRounded);
      $("lastNote").classList.add("flash");

      if (verdict) {
        const detectedName = midiToName(Math.round(verdict.detected));
        const expectedName = midiToName(verdict.expected);

        $("lastNoteMeta").textContent =
          `expected=${expectedName} detected≈${detectedName} ` +
          `cents=${verdict.centsOff.toFixed(1)} ` +
          `Δbeat=${verdict.timingBeats.toFixed(2)} (win≈${timingWindowBeats(state.bpm).toFixed(2)})`;

        $("lastNote").style.outlineColor = verdict.ok ? "#1a7f37" : "#b42318";
        $("status").textContent = verdict.ok ? "✓ correct" : "✗ wrong";

        // Update score counters
        if (verdict.ok) {
          state.successCount++;
        } else {
          state.failCount++;
        }
        updateScoreDisplay();

        // Show full screen feedback (hit zone feedback now handled by visual timeline)
        showFullScreenFeedback(verdict.ok);
      } else {
        $("lastNoteMeta").textContent = `no note within timing window`;
        $("lastNote").style.outlineColor = "#999";
        $("status").textContent = "no match";
      }

      setTimeout(() => $("lastNote").classList.remove("flash"), 200);
    }

    // Update progression
    judgeMisses(beatNow);
    renderNotes();
  } else {
    // Audio processing skipped during metronome ducking, but still update misses
    judgeMisses(beatNow);
    renderNotes();
  }

  // Check if exercise is completed and schedule auto-stop (only for exercises with notes)
  if (!state.exerciseCompleted && state.events.length > 0) {
    const allNotesJudged = state.events.every(ev => ev.judged);
    if (allNotesJudged) {
      state.exerciseCompleted = true;
      // Find the last note's beat to calculate when to stop
      const lastNoteBeat = Math.max(...state.events.map(ev => ev.beat));
      state.exerciseEndBeat = lastNoteBeat + 4; // Stop 4 beats after last note
      $("status").textContent = "exercise complete, stopping in 4 beats...";
    }
  }

  // Auto-stop after exercise completion + 4 beats
  if (state.exerciseCompleted && !state.autoStopScheduled && beatNow >= state.exerciseEndBeat) {
    state.autoStopScheduled = true;
    $("btnStop").click(); // Trigger the stop button
    return; // Exit the loop
  }

  // 10-minute time limit for metronome-only mode (when no notes)
  if (state.events.length === 0 && state.metronomeStartTime) {
    const elapsedTime = now - state.metronomeStartTime;
    if (elapsedTime >= state.metronomeTimeLimit) {
      $("status").textContent = "10-minute metronome session completed";
      $("btnStop").click(); // Trigger the stop button
      return; // Exit the loop
    } else {
      // Show remaining time for metronome-only mode
      const remainingMinutes = Math.ceil((state.metronomeTimeLimit - elapsedTime) / 60);
      if (remainingMinutes <= 1 || Math.floor(elapsedTime) % 60 === 0) {
        $("status").textContent = `metronome (${remainingMinutes} min remaining)`;
      }
    }
  }

  state.rafId = requestAnimationFrame(loop);
}

/**
 * -------------------------
 * Controls
 * -------------------------
 */
function setBpm(bpm) {
  bpm = Math.max(40, Math.min(200, Number(bpm)));
  state.bpm = bpm;
  $("bpm").value = bpm;
  $("bpmNum").value = bpm;
}

$("bpm").addEventListener("input", (e) => setBpm(e.target.value));
$("bpmNum").addEventListener("change", (e) => setBpm(e.target.value));

$("exercise").addEventListener("change", (e) => {
  const selectedFileName = e.target.value;
  const exercise = availableExercises.find(ex => (ex.fileName || "default") === selectedFileName);
  if (exercise) {
    loadExercise(exercise);
  }
});

$("btnMic").addEventListener("click", async () => {
  try {
    if (state.audioCtx || state.micStream) {
      console.log("Microphone already initialized");
      return;
    }

    state.audioCtx = new (window.AudioContext || window.webkitAudioContext)();

    // Request mic
    state.micStream = await navigator.mediaDevices.getUserMedia({
      audio: {
        echoCancellation: false,
        noiseSuppression: false,
        autoGainControl: false,
      }
    });

    const src = state.audioCtx.createMediaStreamSource(state.micStream);

    // Bigger window helps low notes (E2)
    state.analyser = state.audioCtx.createAnalyser();
    state.analyser.fftSize = 8192;

    src.connect(state.analyser);

    $("micStatus").textContent = "Enabled ✓ (listening)";
    $("status").textContent = "mic ready";
    $("btnStart").disabled = false;
    $("btnMic").textContent = "Mic Enabled ✓";
    $("btnMic").disabled = true;
  } catch (e) {
    let errorMessage = "Unknown error";
    let statusMessage = "mic error";

    if (e.name === "NotAllowedError") {
      errorMessage = "Microphone permission denied. Please allow microphone access and try again.";
      statusMessage = "permission denied";
    } else if (e.name === "NotFoundError") {
      errorMessage = "No microphone found. Please connect a microphone and try again.";
      statusMessage = "no microphone";
    } else if (e.name === "NotReadableError") {
      errorMessage = "Microphone in use by another application. Please close other apps and try again.";
      statusMessage = "mic busy";
    } else if (e.name === "OverconstrainedError") {
      errorMessage = "Microphone doesn't support required settings. Trying with default settings...";
      statusMessage = "retrying...";
      // Try again with less strict constraints
      try {
        state.micStream = await navigator.mediaDevices.getUserMedia({ audio: true });
        const src = state.audioCtx.createMediaStreamSource(state.micStream);
        state.analyser = state.audioCtx.createAnalyser();
        state.analyser.fftSize = 8192;
        src.connect(state.analyser);

        $("micStatus").textContent = "Enabled ✓ (basic settings)";
        $("status").textContent = "mic ready";
        $("btnStart").disabled = false;
        $("btnMic").textContent = "Mic Enabled ✓";
        $("btnMic").disabled = true;
        return;
      } catch (retryError) {
        errorMessage = `Microphone failed: ${retryError?.message || retryError}`;
        statusMessage = "mic failed";
      }
    } else {
      errorMessage = `Microphone error: ${e?.message || e}`;
    }

    $("micStatus").textContent = errorMessage;
    $("status").textContent = statusMessage;
    console.error("Microphone initialization failed:", e);

    // Reset state on error
    state.audioCtx = null;
    state.micStream = null;
    state.analyser = null;
  }
});

$("btnStart").addEventListener("click", async () => {
  if (!state.audioCtx) return;

  // Ensure AudioContext is running (some browsers need a user gesture)
  if (state.audioCtx.state === "suspended") {
    await state.audioCtx.resume();
  }

  resetPractice();

  state.practicing = true;

  // Set metronome start time for time limit tracking
  state.metronomeStartTime = state.audioCtx.currentTime;

  const useCountIn = $("countInOn").checked;
  const countInBeats = useCountIn ? BEATS_PER_BAR : 0;

  // Set start time in the future so beatNow starts negative (count-in)
  state.startTime = state.audioCtx.currentTime + beatsToSeconds(countInBeats, state.bpm);

  // Schedule first metronome tick precisely
  const beatDuration = beatsToSeconds(1, state.bpm);
  state.nextMetroTime = state.audioCtx.currentTime + beatDuration;

  $("btnStop").disabled = false;
  $("btnStart").disabled = true;
  $("status").textContent = useCountIn ? "count-in…" : "running";

  state.rafId = requestAnimationFrame(loop);
});

$("btnStop").addEventListener("click", () => {
  state.practicing = false;

  // Cancel animation frame
  if (state.rafId) {
    cancelAnimationFrame(state.rafId);
    state.rafId = null;
  }

  // Reset practice state
  resetPractice();

  // Clean up visual notes
  clearVisualNotes();

  // Clean up audio resources (but keep mic enabled for quick restart)
  if (state.audioCtx && state.audioCtx.state !== "closed") {
    // Don't close the AudioContext to avoid reinitialization overhead
    // Just stop any scheduled audio
    state.ignoreUntil = 0;
    state.nextMetroTime = 0;
  }

  // Update UI
  $("btnStop").disabled = true;
  $("btnStart").disabled = false;
  $("status").textContent = "stopped";

  // Clear detection displays
  $("lastNote").textContent = "—";
  $("lastNoteMeta").textContent = "—";
  $("now").textContent = "—";
  if ($("lastNote").classList.contains("flash")) {
    $("lastNote").classList.remove("flash");
  }
});

// Initial render
setBpm(DEFAULT_BPM);
renderNotes();
updateScoreDisplay();
$("status").textContent = "ready";

// Calculate proper travel distance based on fretboard width
calculateTravelDistance();

// Load available exercises
loadAvailableExercises();

// Recalculate on window resize
window.addEventListener('resize', () => {
  calculateTravelDistance();
});
</script>
</body>
</html>
